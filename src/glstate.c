/*  BuGLe: an OpenGL debugging tool
 *  Copyright (C) 2004, 2005  Bruce Merry
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/* Still TODO:
 * - multiple modelview matrices (for vertex/fragment program)
 * - paletted textures (need to extend color_table_parameter, which is
 *   complicated by the fact that the palette belongs to the texture not
 *   the target).
 * - pixel buffer objects
 * - all the image state (texures, color tables, maps, pixel maps, convolution, stipple etc)
 */

#if HAVE_CONFIG_H
# include <config.h>
#endif
#include "src/utils.h"
#include "src/glstate.h"
#include "src/glutils.h"
#include "src/glexts.h"
#include "src/tracker.h"
#include "common/safemem.h"
#include "budgielib/budgieutils.h"
#include <GL/gl.h>
#include <GL/glext.h>
#include <string.h>
#include <limits.h>
#include <assert.h>
#include <inttypes.h>

#define STATE_NAME(x) #x, x
#define STATE_NAME_EXT(x, ext) #x, x ## ext

/* Flags are divided up as follows:
 * 0-7: fetch function indicator
 * 8-15: multiplexor state
 * 16-23: conditional selection flags
 * 24-31: other
 */
#define STATE_MODE_GLOBAL                   0x00000001    /* glGet* */
#define STATE_MODE_ENABLED                  0x00000002    /* glIsEnabled */
#define STATE_MODE_TEXTURE_ENV              0x00000003    /* glGetTexEnv(GL_TEXTURE_ENV, ...) */
#define STATE_MODE_TEXTURE_FILTER_CONTROL   0x00000004    /* glGetTexEnv(GL_TEXTURE_FILTER_CONTROL, ...) */
#define STATE_MODE_POINT_SPRITE             0x00000005    /* glGetTexEnv(GL_POINT_SPRITE, ...) */
#define STATE_MODE_TEX_PARAMETER            0x00000006    /* glGetTexParameter */
#define STATE_MODE_TEX_LEVEL_PARAMETER      0x00000007    /* glGetTexLevelParameter */
#define STATE_MODE_TEX_GEN                  0x00000008    /* glGetTexGen */
#define STATE_MODE_LIGHT                    0x00000009    /* glGetLight */
#define STATE_MODE_MATERIAL                 0x0000000a    /* glGetMaterial */
#define STATE_MODE_CLIP_PLANE               0x0000000b    /* glGetClipPlane */
#define STATE_MODE_POLYGON_STIPPLE          0x0000000c    /* glGetPolygonStipple */
#define STATE_MODE_COLOR_TABLE_PARAMETER    0x0000000d    /* glGetColorTableParameter */
#define STATE_MODE_CONVOLUTION_PARAMETER    0x0000000e    /* glGetConvolutionParameter */
#define STATE_MODE_HISTOGRAM_PARAMETER      0x0000000f    /* glGetHistogramParameter */
#define STATE_MODE_MINMAX_PARAMETER         0x00000010    /* glGetMinmaxParameter */
#define STATE_MODE_VERTEX_ATTRIB            0x00000011    /* glGetVertexAttrib */
#define STATE_MODE_QUERY                    0x00000012    /* glGetQuery */
#define STATE_MODE_QUERY_OBJECT             0x00000013    /* glGetQueryObject */
#define STATE_MODE_BUFFER_PARAMETER         0x00000014    /* glGetBufferParameter */
#define STATE_MODE_OBJECT_PARAMETER         0x00000015    /* glGetObjectParameterARB */
#define STATE_MODE_SHADER                   0x00000016    /* glGetShader */
#define STATE_MODE_PROGRAM                  0x00000017    /* glGetProgram */
#define STATE_MODE_OBJECT_INFO_LOG          0x00000018    /* glGetInfoLogARB */
#define STATE_MODE_SHADER_INFO_LOG          0x00000019    /* glGetShaderInfoLog */
#define STATE_MODE_PROGRAM_INFO_LOG         0x0000001a    /* glGetProgramInfoLog */
#define STATE_MODE_OBJECT_SHADER_SOURCE     0x0000001b    /* glGetShaderSourceARB */
#define STATE_MODE_SHADER_SOURCE            0x0000001c    /* glGetShaderSource */
#define STATE_MODE_OBJECT_UNIFORM           0x0000001d    /* glGetActiveUniformARB, glGetUniformARB */
#define STATE_MODE_UNIFORM                  0x0000001e    /* glGetActiveUniform, glGetUniform */
#define STATE_MODE_OBJECT_ATTRIB_LOCATION   0x0000001f    /* glGetAttribLocationARB */
#define STATE_MODE_ATTRIB_LOCATION          0x00000020    /* glGetAttribLocation */
#define STATE_MODE_ATTACHED_OBJECTS         0x00000021    /* glGetAttachedObjectsARB */
#define STATE_MODE_ATTACHED_SHADERS         0x00000022    /* glGetAttachedShaders */
#define STATE_MODE_OLD_PROGRAM              0x00000023    /* glGetProgramivARB */
#define STATE_MODE_PROGRAM_ENV_PARAMETER    0x00000024    /* glGetProgramEnvParameterARB */
#define STATE_MODE_PROGRAM_LOCAL_PARAMETER  0x00000025    /* glGetProgramLocalParameterARB */
#define STATE_MODE_COMPRESSED_TEXTURE_FORMATS 0x00000026  /* glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS, ...) */
#define STATE_MODE_MASK                     0x000000ff

#define STATE_MULTIPLEX_ACTIVE_TEXTURE      0x00000100    /* Set active texture */
#define STATE_MULTIPLEX_BIND_TEXTURE        0x00000200    /* Set current texture object */
#define STATE_MULTIPLEX_BIND_BUFFER         0x00000400    /* Set current buffer object (GL_ARRAY_BUFFER) */
#define STATE_MULTIPLEX_BIND_PROGRAM        0x00000800    /* Set current low-level program */

#define STATE_SELECT_NO_1D                  0x00010000    /* Ignore for 1D targets like GL_CONVOLUTION_1D */
#define STATE_SELECT_NO_2D                  0x00020000    /* Ignore for 2D targets like GL_TEXTURE_2D */
#define STATE_SELECT_NON_ZERO               0x00040000    /* Ignore if some field is 0 */
#define STATE_SELECT_NO_PROXY               0x00080000    /* Ignore for proxy targets */
#define STATE_SELECT_COMPRESSED             0x00100000    /* Only applies for compressed textures */
#define STATE_SELECT_VERTEX                 0x00200000    /* Applies only if GL_ARB_vertex_shader is present. */
#define STATE_SELECT_FRAGMENT               0x00400000    /* Applies only to fragment programs/shaders. */
#define STATE_SELECT_TEXTURE_ENV            0x00800000    /* Texture unit state that applies to texture application (limited to GL_MAX_TEXTURE_UNITS_ARB) */
#define STATE_SELECT_TEXTURE_COORD          0x01000000    /* Texture unit state that applies to texture coordinates (limited to GL_MAX_TEXTURE_COORDS_ARB) */
#define STATE_SELECT_TEXTURE_IMAGE          0x02000000    /* Texture unit state that applies to texture images (limited to GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB) */

/* conveniences */
#define STATE_GLOBAL STATE_MODE_GLOBAL
#define STATE_ENABLED STATE_MODE_ENABLED
#define STATE_TEXTURE_ENV (STATE_MODE_TEXTURE_ENV | STATE_MULTIPLEX_ACTIVE_TEXTURE)
#define STATE_TEXTURE_FILTER_CONTROL (STATE_MODE_TEXTURE_FILTER_CONTROL | STATE_MULTIPLEX_ACTIVE_TEXTURE)
#define STATE_POINT_SPRITE (STATE_MODE_POINT_SPRITE | STATE_MULTIPLEX_ACTIVE_TEXTURE)
#define STATE_TEX_UNIT (STATE_MODE_GLOBAL | STATE_MULTIPLEX_ACTIVE_TEXTURE)
#define STATE_TEX_UNIT_ENABLED (STATE_MODE_ENABLED | STATE_MULTIPLEX_ACTIVE_TEXTURE)
#define STATE_TEX_PARAMETER (STATE_MODE_TEX_PARAMETER | STATE_MULTIPLEX_BIND_TEXTURE)
#define STATE_TEX_LEVEL_PARAMETER (STATE_MODE_TEX_LEVEL_PARAMETER | STATE_MULTIPLEX_BIND_TEXTURE)
#define STATE_TEX_GEN (STATE_MODE_TEX_GEN | STATE_MULTIPLEX_ACTIVE_TEXTURE)
#define STATE_LIGHT STATE_MODE_LIGHT
#define STATE_MATERIAL STATE_MODE_MATERIAL
#define STATE_CLIP_PLANE STATE_MODE_CLIP_PLANE
#define STATE_POLYGON_STIPPLE STATE_MODE_POLYGON_STIPPLE
#define STATE_COLOR_TABLE_PARAMETER STATE_MODE_COLOR_TABLE_PARAMETER
#define STATE_CONVOLUTION_PARAMETER STATE_MODE_CONVOLUTION_PARAMETER
#define STATE_HISTOGRAM_PARAMETER STATE_MODE_HISTOGRAM_PARAMETER
#define STATE_MINMAX_PARAMETER STATE_MODE_MINMAX_PARAMETER
#define STATE_VERTEX_ATTRIB STATE_MODE_VERTEX_ATTRIB
#define STATE_QUERY STATE_MODE_QUERY
#define STATE_QUERY_OBJECT STATE_MODE_QUERY_OBJECT
#define STATE_BUFFER_PARAMETER (STATE_MODE_BUFFER_PARAMETER | STATE_MULTIPLEX_BIND_BUFFER)
#define STATE_OBJECT_PARAMETER STATE_MODE_OBJECT_PARAMETER
#define STATE_SHADER STATE_MODE_SHADER
#define STATE_PROGRAM STATE_MODE_PROGRAM
#define STATE_OBJECT_INFO_LOG STATE_MODE_OBJECT_INFO_LOG
#define STATE_SHADER_INFO_LOG STATE_MODE_SHADER_INFO_LOG
#define STATE_PROGRAM_INFO_LOG STATE_MODE_PROGRAM_INFO_LOG
#define STATE_OBJECT_SHADER_SOURCE STATE_MODE_OBJECT_SHADER_SOURCE
#define STATE_SHADER_SOURCE STATE_MODE_SHADER_SOURCE
#define STATE_OBJECT_UNIFORM STATE_MODE_OBJECT_UNIFORM
#define STATE_UNIFORM STATE_MODE_UNIFORM
#define STATE_OBJECT_ATTRIB_LOCATION STATE_MODE_OBJECT_ATTRIB_LOCATION
#define STATE_ATTRIB_LOCATION STATE_MODE_ATTRIB_LOCATION
#define STATE_ATTACHED_OBJECTS STATE_MODE_ATTACHED_OBJECTS
#define STATE_ATTACHED_SHADERS STATE_MODE_ATTACHED_SHADERS
#define STATE_OLD_PROGRAM (STATE_MODE_OLD_PROGRAM | STATE_MULTIPLEX_BIND_PROGRAM)
#define STATE_PROGRAM_ENV_PARAMETER STATE_MODE_PROGRAM_ENV_PARAMETER
#define STATE_PROGRAM_LOCAL_PARAMETER (STATE_MODE_PROGRAM_ENV_PARAMETER | STATE_MULTIPLEX_BIND_PROGRAM)
#define STATE_COMPRESSED_TEXTURE_FORMATS STATE_MODE_COMPRESSED_TEXTURE_FORMATS

static const state_info global_state[] =
{
    { STATE_NAME(GL_CURRENT_COLOR), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_secondary_color
    { STATE_NAME_EXT(GL_CURRENT_SECONDARY_COLOR, _EXT), TYPE_8GLdouble, 4, BUGLE_GL_EXT_secondary_color, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_CURRENT_INDEX), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_CURRENT_NORMAL), TYPE_8GLdouble, 3, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_fog_coord
    { STATE_NAME_EXT(GL_CURRENT_FOG_COORDINATE, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_CURRENT_RASTER_POSITION), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_CURRENT_RASTER_DISTANCE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_CURRENT_RASTER_COLOR), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_CURRENT_RASTER_INDEX), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_CURRENT_RASTER_POSITION_VALID), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_EDGE_FLAG), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_ARB_multitexture
    { STATE_NAME_EXT(GL_CLIENT_ACTIVE_TEXTURE, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_multitexture, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_VERTEX_ARRAY), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_VERTEX_ARRAY_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_VERTEX_ARRAY_TYPE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_VERTEX_ARRAY_STRIDE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_VERTEX_ARRAY_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_NORMAL_ARRAY), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_NORMAL_ARRAY_TYPE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_NORMAL_ARRAY_STRIDE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_NORMAL_ARRAY_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_fog_coord
    { STATE_NAME_EXT(GL_FOG_COORDINATE_ARRAY, _EXT), TYPE_9GLboolean, -1, BUGLE_GL_EXT_fog_coord, STATE_ENABLED },
    { STATE_NAME_EXT(GL_FOG_COORDINATE_ARRAY_TYPE, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_FOG_COORDINATE_ARRAY_STRIDE, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_FOG_COORDINATE_ARRAY_POINTER, _EXT), TYPE_P6GLvoid, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_COLOR_ARRAY), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_COLOR_ARRAY_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_COLOR_ARRAY_TYPE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_COLOR_ARRAY_STRIDE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_COLOR_ARRAY_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_secondary_color
    { STATE_NAME_EXT(GL_SECONDARY_COLOR_ARRAY, _EXT), TYPE_9GLboolean, -1, BUGLE_GL_EXT_fog_coord, STATE_ENABLED },
    { STATE_NAME_EXT(GL_SECONDARY_COLOR_ARRAY_SIZE, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_SECONDARY_COLOR_ARRAY_TYPE, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_SECONDARY_COLOR_ARRAY_STRIDE, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_SECONDARY_COLOR_ARRAY_POINTER, _EXT), TYPE_P6GLvoid, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_INDEX_ARRAY), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_INDEX_ARRAY_TYPE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_INDEX_ARRAY_STRIDE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_INDEX_ARRAY_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_EDGE_FLAG_ARRAY), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_EDGE_FLAG_ARRAY_STRIDE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_EDGE_FLAG_ARRAY_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_ARB_vertex_buffer_object
    { STATE_NAME_EXT(GL_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_VERTEX_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_NORMAL_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_COLOR_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_INDEX_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_EDGE_FLAG_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_ELEMENT_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_GLOBAL },
#endif
    /* FIXME: these are matrix stacks, not just single matrices */
    { STATE_NAME(GL_COLOR_MATRIX), TYPE_8GLdouble, 16, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_MODELVIEW_MATRIX), TYPE_8GLdouble, 16, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PROJECTION_MATRIX), TYPE_8GLdouble, 16, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_VIEWPORT), TYPE_5GLint, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_DEPTH_RANGE), TYPE_8GLdouble, 2, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_COLOR_MATRIX_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_MODELVIEW_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PROJECTION_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MATRIX_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_NORMALIZE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
#ifdef GL_EXT_rescale_normal
    { STATE_NAME_EXT(GL_RESCALE_NORMAL, _EXT), TYPE_9GLboolean, -1, BUGLE_GL_EXT_rescale_normal, STATE_ENABLED },
#endif
    { STATE_NAME(GL_FOG_COLOR), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FOG_INDEX), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FOG_DENSITY), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FOG_START), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FOG_END), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FOG_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FOG), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
#ifdef GL_EXT_fog_coord
    { STATE_NAME_EXT(GL_FOG_COORDINATE_SOURCE, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_fog_coord, STATE_GLOBAL },
#endif
#ifdef GL_EXT_secondary_color
    { STATE_NAME_EXT(GL_COLOR_SUM, _EXT), TYPE_9GLboolean, -1, BUGLE_GL_EXT_secondary_color, STATE_ENABLED },
#endif
    { STATE_NAME(GL_SHADE_MODEL), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LIGHTING), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_COLOR_MATERIAL), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_COLOR_MATERIAL_PARAMETER), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_COLOR_MATERIAL_FACE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LIGHT_MODEL_AMBIENT), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LIGHT_MODEL_LOCAL_VIEWER), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LIGHT_MODEL_TWO_SIDE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_separate_specular_color
    { STATE_NAME(GL_LIGHT_MODEL_COLOR_CONTROL), TYPE_6GLenum, -1, BUGLE_GL_EXT_separate_specular_color, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_POINT_SIZE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_POINT_SMOOTH), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
#ifdef GL_ARB_point_sprite
    { STATE_NAME_EXT(GL_POINT_SPRITE, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_point_sprite, STATE_ENABLED },
#endif
#ifdef GL_EXT_point_parameters
    { STATE_NAME_EXT(GL_POINT_SIZE_MIN, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_point_parameters, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_POINT_SIZE_MAX, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_point_parameters, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_POINT_FADE_THRESHOLD_SIZE, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_point_parameters, STATE_GLOBAL },
    { "GL_POINT_DISTANCE_ATTENUATION", GL_DISTANCE_ATTENUATION_EXT, TYPE_8GLdouble, 3, BUGLE_GL_EXT_point_parameters, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_LINE_WIDTH), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LINE_SMOOTH), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_LINE_STIPPLE_PATTERN), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LINE_STIPPLE_REPEAT), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LINE_STIPPLE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_CULL_FACE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_CULL_FACE_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FRONT_FACE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_POLYGON_SMOOTH), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_POLYGON_MODE), TYPE_6GLenum, 2, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_POLYGON_OFFSET_FACTOR), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_POLYGON_OFFSET_UNITS), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_POLYGON_OFFSET_POINT), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_POLYGON_OFFSET_LINE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_POLYGON_OFFSET_FILL), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_POLYGON_STIPPLE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { "PolygonStipple", GL_NONE, TYPE_16GLpolygonstipple, -1, BUGLE_GL_VERSION_1_1, STATE_POLYGON_STIPPLE },
#ifdef GL_ARB_multisample
    { STATE_NAME_EXT(GL_MULTISAMPLE, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_multisample, STATE_ENABLED },
    { STATE_NAME_EXT(GL_SAMPLE_ALPHA_TO_COVERAGE, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_multisample, STATE_ENABLED },
    { STATE_NAME_EXT(GL_SAMPLE_ALPHA_TO_ONE, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_multisample, STATE_ENABLED },
    { STATE_NAME_EXT(GL_SAMPLE_COVERAGE, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_multisample, STATE_ENABLED },
    { STATE_NAME_EXT(GL_SAMPLE_COVERAGE_VALUE, _ARB), TYPE_8GLdouble, -1, BUGLE_GL_ARB_multisample, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_SAMPLE_COVERAGE_INVERT, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_multisample, STATE_GLOBAL },
#endif
#ifdef GL_ARB_multitexture
    { STATE_NAME_EXT(GL_ACTIVE_TEXTURE, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_multitexture, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_SCISSOR_TEST), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_SCISSOR_BOX), TYPE_5GLint, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ALPHA_TEST), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_ALPHA_TEST_FUNC), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ALPHA_TEST_REF), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_TEST), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_STENCIL_FUNC), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_VALUE_MASK), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_REF), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_FAIL), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_PASS_DEPTH_FAIL), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_PASS_DEPTH_PASS), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_VERSION_2_0
    { STATE_NAME(GL_STENCIL_BACK_FUNC), TYPE_6GLenum, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_BACK_VALUE_MASK), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_BACK_REF), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_BACK_FAIL), TYPE_6GLenum, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_BACK_PASS_DEPTH_FAIL), TYPE_6GLenum, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_BACK_PASS_DEPTH_PASS), TYPE_6GLenum, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_DEPTH_TEST), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_DEPTH_FUNC), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_BLEND), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
#ifdef GL_EXT_blend_func_separate
    { STATE_NAME_EXT(GL_BLEND_SRC_RGB, _EXT), TYPE_15GLalternateenum, -1, BUGLE_GL_EXT_blend_func_separate, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_BLEND_SRC_ALPHA, _EXT), TYPE_15GLalternateenum, -1, BUGLE_GL_EXT_blend_func_separate, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_BLEND_DST_RGB, _EXT), TYPE_15GLalternateenum, -1, BUGLE_GL_EXT_blend_func_separate, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_BLEND_DST_ALPHA, _EXT), TYPE_15GLalternateenum, -1, BUGLE_GL_EXT_blend_func_separate, STATE_GLOBAL },
    { STATE_NAME(GL_BLEND_SRC), TYPE_15GLalternateenum, -1, ~BUGLE_GL_EXT_blend_func_separate, STATE_GLOBAL },
    { STATE_NAME(GL_BLEND_DST), TYPE_15GLalternateenum, -1, ~BUGLE_GL_EXT_blend_func_separate, STATE_GLOBAL },
#else
    { STATE_NAME(GL_BLEND_SRC), TYPE_15GLalternateenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_BLEND_DST), TYPE_15GLalternateenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#endif
    { "GL_BLEND_EQUATION_RGB", GL_BLEND_EQUATION, TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_blend_equation_separate
    { STATE_NAME_EXT(GL_BLEND_EQUATION_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_blend_equation_separate, STATE_GLOBAL },
#endif
#ifdef GL_EXT_blend_color
    { STATE_NAME_EXT(GL_BLEND_COLOR, _EXT), TYPE_8GLdouble, 4, BUGLE_EXTGROUP_blend_color, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_DITHER), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_INDEX_LOGIC_OP), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_COLOR_LOGIC_OP), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_LOGIC_OP_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_ATI_draw_buffers
    { STATE_NAME(GL_DRAW_BUFFER), TYPE_6GLenum, -1, ~BUGLE_GL_ATI_draw_buffers, STATE_GLOBAL },
#else
    { STATE_NAME(GL_DRAW_BUFFER), TYPE_6GLenum, -1, GL_VERSION_1_1, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_INDEX_WRITEMASK), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_COLOR_WRITEMASK), TYPE_9GLboolean, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_DEPTH_WRITEMASK), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_WRITEMASK), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_VERSION_2_0
    { STATE_NAME(GL_STENCIL_BACK_WRITEMASK), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_COLOR_CLEAR_VALUE), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_INDEX_CLEAR_VALUE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_DEPTH_CLEAR_VALUE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_CLEAR_VALUE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ACCUM_CLEAR_VALUE), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_UNPACK_SWAP_BYTES), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_UNPACK_LSB_FIRST), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_texture3D
    { STATE_NAME_EXT(GL_UNPACK_IMAGE_HEIGHT, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_texture3D, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_UNPACK_SKIP_IMAGES, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_texture3D, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_UNPACK_ROW_LENGTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_UNPACK_SKIP_ROWS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_UNPACK_SKIP_PIXELS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_UNPACK_ALIGNMENT), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PACK_SWAP_BYTES), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PACK_LSB_FIRST), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_texture3D
    { STATE_NAME_EXT(GL_PACK_IMAGE_HEIGHT, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_texture3D, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_PACK_SKIP_IMAGES, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_texture3D, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_PACK_ROW_LENGTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PACK_SKIP_ROWS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PACK_SKIP_PIXELS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PACK_ALIGNMENT), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAP_COLOR), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAP_STENCIL), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_INDEX_SHIFT), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_INDEX_OFFSET), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_RED_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_GREEN_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_BLUE_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ALPHA_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_DEPTH_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_RED_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_GREEN_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_BLUE_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ALPHA_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_DEPTH_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_COLOR_TABLE), TYPE_9GLboolean, -1, BUGLE_GL_ARB_imaging, STATE_ENABLED },
    { STATE_NAME(GL_POST_CONVOLUTION_COLOR_TABLE), TYPE_9GLboolean, -1, BUGLE_GL_ARB_imaging, STATE_ENABLED },
    { STATE_NAME(GL_POST_COLOR_MATRIX_COLOR_TABLE), TYPE_9GLboolean, -1, BUGLE_GL_ARB_imaging, STATE_ENABLED },
    /* FIXME: glGetColorTable */
    /* FIXME: glConvolution_xD enable missing */
    /* FIXME: glGetConvolutionFilter */
    /* FIXME: glGetSeparableFilter */
    { STATE_NAME(GL_POST_CONVOLUTION_RED_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_CONVOLUTION_GREEN_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_CONVOLUTION_BLUE_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_CONVOLUTION_ALPHA_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_CONVOLUTION_RED_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_CONVOLUTION_GREEN_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_CONVOLUTION_BLUE_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_CONVOLUTION_ALPHA_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_RED_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_GREEN_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_BLUE_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_ALPHA_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_RED_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_GREEN_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_BLUE_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_POST_COLOR_MATRIX_ALPHA_BIAS), TYPE_8GLdouble, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_HISTOGRAM), TYPE_9GLboolean, -1, BUGLE_GL_ARB_imaging, STATE_ENABLED },
    /* FIXME: glGetHistogram */
    { STATE_NAME(GL_MINMAX), TYPE_9GLboolean, -1, BUGLE_GL_ARB_imaging, STATE_ENABLED },
    /* FIXME: glGetMinmax */
    { STATE_NAME(GL_ZOOM_X), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ZOOM_Y), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    /* FIXME: glGetPixelMap */
    { STATE_NAME(GL_PIXEL_MAP_I_TO_I_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_S_TO_S_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_I_TO_R_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_I_TO_G_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_I_TO_B_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_I_TO_A_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_R_TO_R_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_G_TO_G_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_B_TO_B_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_PIXEL_MAP_A_TO_A_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_READ_BUFFER), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    /* FIXME: glGetMap */
    { STATE_NAME(GL_MAP1_VERTEX_3), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_VERTEX_4), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_INDEX), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_COLOR_4), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_NORMAL), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_TEXTURE_COORD_1), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_TEXTURE_COORD_2), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_TEXTURE_COORD_3), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_TEXTURE_COORD_4), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_VERTEX_3), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_VERTEX_4), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_INDEX), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_COLOR_4), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_NORMAL), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_TEXTURE_COORD_1), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_TEXTURE_COORD_2), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_TEXTURE_COORD_3), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP2_TEXTURE_COORD_4), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
    { STATE_NAME(GL_MAP1_GRID_DOMAIN), TYPE_8GLdouble, 2, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAP2_GRID_DOMAIN), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAP1_GRID_SEGMENTS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAP2_GRID_SEGMENTS), TYPE_5GLint, 2, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_AUTO_NORMAL), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED },
#ifdef GL_VERSION_2_0
    { STATE_NAME(GL_CURRENT_PROGRAM), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_GLOBAL },
#endif
#ifdef GL_ARB_vertex_program
    { STATE_NAME_EXT(GL_VERTEX_PROGRAM_TWO_SIDE, _ARB), TYPE_9GLboolean, -1, BUGLE_EXTGROUP_vp_options, STATE_ENABLED },
    { STATE_NAME_EXT(GL_VERTEX_PROGRAM_POINT_SIZE, _ARB), TYPE_9GLboolean, -1, BUGLE_EXTGROUP_vp_options, STATE_ENABLED },
#endif
    { STATE_NAME(GL_PERSPECTIVE_CORRECTION_HINT), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_POINT_SMOOTH_HINT), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LINE_SMOOTH_HINT), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_POLYGON_SMOOTH_HINT), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FOG_HINT), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_SGIS_generate_mipmap
    { STATE_NAME_EXT(GL_GENERATE_MIPMAP_HINT, _SGIS), TYPE_6GLenum, -1, BUGLE_GL_SGIS_generate_mipmap, STATE_GLOBAL },
#endif
#ifdef GL_ARB_texture_compression
    { STATE_NAME_EXT(GL_TEXTURE_COMPRESSION_HINT, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_texture_compression, STATE_GLOBAL },
#endif
    /* glext.h v21 doesn't define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB (based on older version of spec) */
#if defined(GL_ARB_fragment_shader) && defined(GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB)
    { STATE_NAME_EXT(GL_FRAGMENT_SHADER_DERIVATIVE_HINT, _ARB), TYPE_6GLenum, -1, BUGLE_EXTGROUP_fragment_shader, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_MAX_LIGHTS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_CLIP_PLANES), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_COLOR_MATRIX_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_MODELVIEW_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_PROJECTION_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_TEXTURE_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_SUBPIXEL_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_texture3D
    { STATE_NAME_EXT(GL_MAX_3D_TEXTURE_SIZE, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_texture3D, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_MAX_TEXTURE_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_EXT_texture_lod_bias
    { STATE_NAME_EXT(GL_MAX_TEXTURE_LOD_BIAS, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_texture_lod_bias, STATE_GLOBAL },
#endif
#ifdef GL_ARB_texture_cube_map
    { STATE_NAME_EXT(GL_MAX_CUBE_MAP_TEXTURE_SIZE, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_texture_cube_map, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_MAX_PIXEL_MAP_TABLE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_NAME_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_LIST_NESTING), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_EVAL_ORDER), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_VIEWPORT_DIMS), TYPE_5GLint, 2, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_ATTRIB_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_AUX_BUFFERS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_RGBA_MODE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_INDEX_MODE), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_DOUBLEBUFFER), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STEREO), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ALIASED_POINT_SIZE_RANGE), TYPE_8GLdouble, 2, BUGLE_GL_VERSION_1_2, STATE_GLOBAL },
    { "GL_SMOOTH_POINT_SIZE_RANGE", GL_POINT_SIZE_RANGE, TYPE_8GLdouble, 2, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { "GL_SMOOTH_POINT_SIZE_GRANULARITY", GL_POINT_SIZE_GRANULARITY, TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ALIASED_LINE_WIDTH_RANGE), TYPE_8GLdouble, 2, BUGLE_GL_VERSION_1_2, STATE_GLOBAL },
    { "GL_SMOOTH_LINE_WIDTH_RANGE", GL_LINE_WIDTH_RANGE, TYPE_8GLdouble, 2, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { "GL_SMOOTH_LINE_WIDTH_GRANULARITY", GL_LINE_WIDTH_GRANULARITY, TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_ELEMENTS_INDICES), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_ELEMENTS_VERTICES), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_ARB_multitexture
    { STATE_NAME_EXT(GL_MAX_TEXTURE_UNITS, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_multitexture, STATE_GLOBAL },
#endif
#ifdef GL_ARB_multisample
    { STATE_NAME_EXT(GL_SAMPLE_BUFFERS, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_multisample, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_SAMPLES, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_multisample, STATE_GLOBAL },
#endif
#ifdef GL_ARB_texture_compression
    { STATE_NAME_EXT(GL_COMPRESSED_TEXTURE_FORMATS, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_texture_compression, STATE_COMPRESSED_TEXTURE_FORMATS },
    { STATE_NAME_EXT(GL_NUM_COMPRESSED_TEXTURE_FORMATS, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_texture_compression, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_EXTENSIONS), TYPE_PKc, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_RENDERER), TYPE_PKc, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    /* SHADING_LANGUAGE_VERSION was only added in a later version of the spec */
#if defined(GL_ARB_shading_language_100) && defined(GL_SHADING_LANGUAGE_VERSION_ARB)
    { STATE_NAME_EXT(GL_SHADING_LANGUAGE_VERSION, _ARB), TYPE_PKc, -1, BUGLE_GL_ARB_shading_language_100, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_VENDOR), TYPE_PKc, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_VERSION), TYPE_PKc, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
#ifdef GL_ARB_vertex_program
    { STATE_NAME_EXT(GL_MAX_VERTEX_ATTRIBS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_vertex_attrib, STATE_GLOBAL },
#endif
#ifdef GL_ARB_vertex_shader
    { STATE_NAME_EXT(GL_MAX_VERTEX_UNIFORM_COMPONENTS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_vertex_shader, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_MAX_VARYING_FLOATS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_vertex_shader, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_vertex_shader, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_vertex_shader, STATE_GLOBAL },
#endif
#ifdef GL_ARB_fragment_program
    { STATE_NAME_EXT(GL_MAX_TEXTURE_IMAGE_UNITS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_texunits, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_MAX_TEXTURE_COORDS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_texunits, STATE_GLOBAL },
#endif
#ifdef GL_ARB_fragment_shader
    { STATE_NAME_EXT(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_fragment_shader, STATE_GLOBAL },
#endif
    /* Note: The GL 2.0 spec duplicates some entries at this point */
#ifdef GL_ATI_draw_buffers
    { STATE_NAME_EXT(GL_MAX_DRAW_BUFFERS, _ATI), TYPE_5GLint, -1, BUGLE_GL_ATI_draw_buffers, STATE_GLOBAL },
#endif
    { STATE_NAME(GL_RED_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_GREEN_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_BLUE_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ALPHA_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_INDEX_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_DEPTH_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_STENCIL_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ACCUM_RED_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ACCUM_GREEN_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ACCUM_BLUE_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ACCUM_ALPHA_BITS), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LIST_BASE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LIST_INDEX), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_LIST_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_ATTRIB_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_CLIENT_ATTRIB_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_NAME_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_RENDER_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_SELECTION_BUFFER_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_SELECTION_BUFFER_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FEEDBACK_BUFFER_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FEEDBACK_BUFFER_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    { STATE_NAME(GL_FEEDBACK_BUFFER_TYPE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_GLOBAL },
    /* FIXME: glGetError */

    /* The remaining state is not part of the GL 2.0 state, but pure
     * extensions. The vertex and fragment program stuff are named with _ARB
     * suffix, to avoid confusion with the GLSL. They can probably never
     * be promoted to core, since this would lead to name collisions with GLSL.
     */
#if defined(GL_ARB_vertex_program) || defined(GL_ARB_fragment_program)
    { STATE_NAME(GL_PROGRAM_ERROR_POSITION_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_GLOBAL },
    { STATE_NAME(GL_PROGRAM_ERROR_STRING_ARB), TYPE_PKc, -1, BUGLE_EXTGROUP_old_program, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_PROGRAM_MATRICES_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_GLOBAL },
    { STATE_NAME(GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_GLOBAL },
#endif
#ifdef GL_EXT_texture_filter_anisotropic
    { STATE_NAME_EXT(GL_MAX_TEXTURE_MAX_ANISOTROPY, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_texture_filter_anisotropic, STATE_GLOBAL },
#endif
#ifdef GL_NV_texture_rectangle
    { STATE_NAME_EXT(GL_MAX_RECTANGLE_TEXTURE_SIZE, _NV), TYPE_5GLint, -1, BUGLE_GL_NV_texture_rectangle, STATE_GLOBAL },
#endif
#ifdef GL_NV_depth_clamp
    { STATE_NAME_EXT(GL_DEPTH_CLAMP, _NV), TYPE_9GLboolean, -1, BUGLE_GL_NV_depth_clamp, STATE_ENABLED },
#endif
#ifdef GL_NV_light_max_exponent
    { STATE_NAME_EXT(GL_MAX_SHININESS, _NV), TYPE_5GLint, -1, BUGLE_GL_NV_light_max_exponent, STATE_GLOBAL },
    { STATE_NAME_EXT(GL_MAX_SPOT_EXPONENT, _NV), TYPE_5GLint, -1, BUGLE_GL_NV_light_max_exponent, STATE_GLOBAL },
#endif
#ifdef GL_NV_multisample_filter_hint
    { STATE_NAME_EXT(GL_MULTISAMPLE_FILTER_HINT, _NV), TYPE_6GLenum, -1, BUGLE_GL_NV_multisample_filter_hint, STATE_GLOBAL },
#endif
#ifdef GL_IBM_rasterpos_clip
    { STATE_NAME_EXT(GL_RASTER_POSITION_UNCLIPPED, _IBM), TYPE_9GLboolean, -1, BUGLE_GL_IBM_rasterpos_clip, STATE_ENABLED },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info tex_parameter_state[] =
{
    { STATE_NAME(GL_TEXTURE_BORDER_COLOR), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_TEX_PARAMETER },
    { STATE_NAME(GL_TEXTURE_MIN_FILTER), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_PARAMETER },
    { STATE_NAME(GL_TEXTURE_MAG_FILTER), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_PARAMETER },
    { STATE_NAME(GL_TEXTURE_WRAP_S), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_PARAMETER },
    { STATE_NAME(GL_TEXTURE_WRAP_T), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_PARAMETER | STATE_SELECT_NO_1D },
#ifdef GL_EXT_texture3D
    { STATE_NAME_EXT(GL_TEXTURE_WRAP_R, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture3D, STATE_TEX_PARAMETER | STATE_SELECT_NO_1D | STATE_SELECT_NO_2D },
#endif
    { STATE_NAME(GL_TEXTURE_PRIORITY), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_PARAMETER },
    { STATE_NAME(GL_TEXTURE_RESIDENT), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_PARAMETER },
#ifdef GL_SGIS_texture_lod
    { STATE_NAME_EXT(GL_TEXTURE_MIN_LOD, _SGIS), TYPE_8GLdouble, -1, BUGLE_GL_SGIS_texture_lod, STATE_TEX_PARAMETER },
    { STATE_NAME_EXT(GL_TEXTURE_MAX_LOD, _SGIS), TYPE_8GLdouble, -1, BUGLE_GL_SGIS_texture_lod, STATE_TEX_PARAMETER },
    { STATE_NAME_EXT(GL_TEXTURE_BASE_LEVEL, _SGIS), TYPE_5GLint, -1, BUGLE_GL_SGIS_texture_lod, STATE_TEX_PARAMETER },
    { STATE_NAME_EXT(GL_TEXTURE_MAX_LEVEL, _SGIS), TYPE_5GLint, -1, BUGLE_GL_SGIS_texture_lod, STATE_TEX_PARAMETER },
#endif
#ifdef GL_EXT_depth_bounds_test
    { STATE_NAME_EXT(GL_DEPTH_BOUNDS_TEST, _EXT), TYPE_9GLboolean, -1, BUGLE_GL_EXT_depth_bounds_test, STATE_ENABLED },
    { STATE_NAME_EXT(GL_DEPTH_BOUNDS, _EXT), TYPE_8GLdouble, 2, BUGLE_GL_EXT_depth_bounds_test, STATE_GLOBAL },
#endif
#ifdef GL_EXT_texture_lod_bias
    { STATE_NAME_EXT(GL_TEXTURE_LOD_BIAS, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_texture_lod_bias, STATE_TEX_PARAMETER },
#endif
#ifdef GL_ARB_depth_texture
    { STATE_NAME_EXT(GL_DEPTH_TEXTURE_MODE, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_depth_texture, STATE_TEX_PARAMETER },
#endif
#ifdef GL_ARB_shadow
    { STATE_NAME_EXT(GL_TEXTURE_COMPARE_MODE, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_shadow, STATE_TEX_PARAMETER },
    { STATE_NAME_EXT(GL_TEXTURE_COMPARE_FUNC, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_shadow, STATE_TEX_PARAMETER },
#endif
#ifdef GL_SGIS_generate_mipmap
    { STATE_NAME_EXT(GL_GENERATE_MIPMAP, _SGIS), TYPE_9GLboolean, -1, BUGLE_GL_SGIS_generate_mipmap, STATE_TEX_PARAMETER },
#endif

    /* Non-GL2.0 state */
#ifdef GL_EXT_texture_filter_anisotropic
    { STATE_NAME_EXT(GL_TEXTURE_MAX_ANISOTROPY, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_texture_filter_anisotropic, STATE_TEX_PARAMETER },
#endif
#ifdef GL_NV_texture_expand_normal
    { STATE_NAME_EXT(GL_TEXTURE_UNSIGNED_REMAP_MODE, _NV), TYPE_6GLenum, -1, BUGLE_GL_NV_texture_expand_normal, STATE_TEX_PARAMETER },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info tex_level_parameter_state[] =
{
    { STATE_NAME(GL_TEXTURE_WIDTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_HEIGHT), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER | STATE_SELECT_NO_1D },
#ifdef GL_EXT_texture3D
    { STATE_NAME_EXT(GL_TEXTURE_DEPTH, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_texture3D, STATE_TEX_LEVEL_PARAMETER | STATE_SELECT_NO_1D | STATE_SELECT_NO_2D },
#endif
    { STATE_NAME(GL_TEXTURE_BORDER), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_INTERNAL_FORMAT), TYPE_16GLcomponentsenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_RED_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_GREEN_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_BLUE_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_ALPHA_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_LUMINANCE_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
    { STATE_NAME(GL_TEXTURE_INTENSITY_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_LEVEL_PARAMETER },
#ifdef GL_ARB_depth_texture
    { STATE_NAME_EXT(GL_TEXTURE_DEPTH_SIZE, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_depth_texture, STATE_TEX_LEVEL_PARAMETER },
#endif
#ifdef GL_EXT_palette_texture
    { STATE_NAME_EXT(GL_TEXTURE_INDEX_SIZE, _EXT), TYPE_5GLint, -1, BUGLE_GL_EXT_palette_texture, STATE_TEX_LEVEL_PARAMETER },
#endif
#ifdef GL_ARB_texture_compression
    { STATE_NAME_EXT(GL_TEXTURE_COMPRESSED, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_texture_compression, STATE_TEX_LEVEL_PARAMETER },
#ifdef GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB /* Not defined in glext.h version 21??? */
    { STATE_NAME_EXT(GL_TEXTURE_COMPRESSED_IMAGE_SIZE, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_texture_compression, STATE_TEX_LEVEL_PARAMETER | STATE_SELECT_NO_PROXY | STATE_SELECT_COMPRESSED },
#endif
#endif /* GL_ARB_texture_compression */
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info tex_unit_state[] =
{
    { STATE_NAME(GL_TEXTURE_COORD_ARRAY), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_COORD_ARRAY_SIZE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_COORD_ARRAY_TYPE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_COORD_ARRAY_STRIDE), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_COORD_ARRAY_POINTER), TYPE_P6GLvoid, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
#ifdef GL_ARB_vertex_buffer_object
    { STATE_NAME_EXT(GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
#endif
#ifdef GL_ARB_point_sprite
    { STATE_NAME_EXT(GL_COORD_REPLACE, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_point_sprite, STATE_POINT_SPRITE | STATE_SELECT_TEXTURE_COORD },
#endif
    { STATE_NAME(GL_TEXTURE_ENV_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME(GL_TEXTURE_ENV_COLOR), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV  },
#ifdef GL_EXT_texture_lod_bias
    { STATE_NAME_EXT(GL_TEXTURE_LOD_BIAS, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_texture_lod_bias, STATE_TEXTURE_FILTER_CONTROL | STATE_SELECT_TEXTURE_IMAGE },
#endif
    { STATE_NAME(GL_TEXTURE_GEN_S), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_GEN_T), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_GEN_R), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_GEN_Q), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_COORD },
#ifdef GL_EXT_texture_env_combine
    { STATE_NAME_EXT(GL_COMBINE_RGB, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_COMBINE_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_SOURCE0_RGB, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_SOURCE1_RGB, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_SOURCE2_RGB, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_SOURCE0_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_SOURCE1_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_SOURCE2_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_OPERAND0_RGB, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_OPERAND1_RGB, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_OPERAND2_RGB, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_OPERAND0_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_OPERAND1_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_OPERAND2_ALPHA, _EXT), TYPE_6GLenum, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME_EXT(GL_RGB_SCALE, _EXT), TYPE_8GLdouble, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME(GL_ALPHA_SCALE), TYPE_8GLdouble, -1, BUGLE_GL_EXT_texture_env_combine, STATE_TEXTURE_ENV | STATE_SELECT_TEXTURE_ENV },
#endif
    { STATE_NAME(GL_CURRENT_TEXTURE_COORDS), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_CURRENT_RASTER_TEXTURE_COORDS), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_MATRIX), TYPE_8GLdouble, 16, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_STACK_DEPTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_COORD },
    { STATE_NAME(GL_TEXTURE_1D), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_ENV },
    { STATE_NAME(GL_TEXTURE_2D), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_ENV },
#ifdef GL_EXT_texture3D
    { STATE_NAME_EXT(GL_TEXTURE_3D, _EXT), TYPE_9GLboolean, -1, BUGLE_GL_EXT_texture3D, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_ENV },
#endif
#ifdef GL_ARB_texture_cube_map
    { STATE_NAME_EXT(GL_TEXTURE_CUBE_MAP, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_texture_cube_map, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_ENV },
#endif
#ifdef GL_NV_texture_rectangle
    { STATE_NAME_EXT(GL_TEXTURE_RECTANGLE, _NV), TYPE_9GLboolean, -1, BUGLE_GL_NV_texture_rectangle, STATE_TEX_UNIT_ENABLED | STATE_SELECT_TEXTURE_ENV },
#endif
    { STATE_NAME(GL_TEXTURE_BINDING_1D), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_IMAGE },
    { STATE_NAME(GL_TEXTURE_BINDING_2D), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_IMAGE },
#ifdef GL_VERSION_1_2
    { STATE_NAME(GL_TEXTURE_BINDING_3D), TYPE_5GLint, -1, BUGLE_GL_VERSION_1_2, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_IMAGE }, /* Note: GL_EXT_texture3D doesn't define this! */
#endif
#ifdef GL_ARB_texture_cube_map
    { STATE_NAME_EXT(GL_TEXTURE_BINDING_CUBE_MAP, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_texture_cube_map, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_IMAGE },
#endif
#ifdef GL_NV_texture_rectangle
    { STATE_NAME_EXT(GL_TEXTURE_BINDING_RECTANGLE, _NV), TYPE_5GLint, -1, BUGLE_GL_NV_texture_rectangle, STATE_TEX_UNIT | STATE_SELECT_TEXTURE_IMAGE },
#endif
    /* FIXME: GetTexImage */
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info tex_gen_state[] =
{
    { STATE_NAME(GL_EYE_PLANE), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_TEX_GEN },
    { STATE_NAME(GL_OBJECT_PLANE), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_TEX_GEN },
    { STATE_NAME(GL_TEXTURE_GEN_MODE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_1_1, STATE_TEX_GEN },
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info light_state[] =
{
    { STATE_NAME(GL_AMBIENT), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_DIFFUSE), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_SPECULAR), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_POSITION), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_CONSTANT_ATTENUATION), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_LINEAR_ATTENUATION), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_QUADRATIC_ATTENUATION), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_SPOT_DIRECTION), TYPE_8GLdouble, 3, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_SPOT_EXPONENT), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { STATE_NAME(GL_SPOT_CUTOFF), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_LIGHT },
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info material_state[] =
{
    { STATE_NAME(GL_AMBIENT), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_MATERIAL },
    { STATE_NAME(GL_DIFFUSE), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_MATERIAL },
    { STATE_NAME(GL_SPECULAR), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_MATERIAL },
    { STATE_NAME(GL_EMISSION), TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_MATERIAL },
    { STATE_NAME(GL_SHININESS), TYPE_8GLdouble, -1, BUGLE_GL_VERSION_1_1, STATE_MATERIAL },
    { STATE_NAME(GL_COLOR_INDEXES), TYPE_8GLdouble, 3, BUGLE_GL_VERSION_1_1, STATE_MATERIAL },
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info color_table_parameter_state[] =
{
    { STATE_NAME(GL_COLOR_TABLE_FORMAT), TYPE_6GLenum, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_WIDTH), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_RED_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_GREEN_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_BLUE_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_ALPHA_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_LUMINANCE_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_INTENSITY_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER },
    { STATE_NAME(GL_COLOR_TABLE_SCALE), TYPE_8GLdouble, 4, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER | STATE_SELECT_NO_PROXY },
    { STATE_NAME(GL_COLOR_TABLE_BIAS), TYPE_8GLdouble, 4, BUGLE_GL_ARB_imaging, STATE_COLOR_TABLE_PARAMETER | STATE_SELECT_NO_PROXY },
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info convolution_parameter_state[] =
{
    { STATE_NAME(GL_CONVOLUTION_BORDER_COLOR), TYPE_8GLdouble, 4, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER },
    { STATE_NAME(GL_CONVOLUTION_BORDER_MODE), TYPE_6GLenum, -1, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER },
    { STATE_NAME(GL_CONVOLUTION_FILTER_SCALE), TYPE_8GLdouble, 4, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER },
    { STATE_NAME(GL_CONVOLUTION_FILTER_BIAS), TYPE_8GLdouble, 4, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER },
    { STATE_NAME(GL_CONVOLUTION_FORMAT), TYPE_6GLenum, -1, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER },
    { STATE_NAME(GL_CONVOLUTION_WIDTH), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER },
    { STATE_NAME(GL_CONVOLUTION_HEIGHT), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER | STATE_SELECT_NO_1D },
    { STATE_NAME(GL_MAX_CONVOLUTION_WIDTH), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER },
    { STATE_NAME(GL_MAX_CONVOLUTION_HEIGHT), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_CONVOLUTION_PARAMETER | STATE_SELECT_NO_1D },
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info histogram_parameter_state[] =
{
    { STATE_NAME(GL_HISTOGRAM_WIDTH), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { STATE_NAME(GL_HISTOGRAM_FORMAT), TYPE_6GLenum, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { STATE_NAME(GL_HISTOGRAM_RED_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { STATE_NAME(GL_HISTOGRAM_GREEN_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { STATE_NAME(GL_HISTOGRAM_BLUE_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { STATE_NAME(GL_HISTOGRAM_ALPHA_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { STATE_NAME(GL_HISTOGRAM_LUMINANCE_SIZE), TYPE_5GLint, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { STATE_NAME(GL_HISTOGRAM_SINK), TYPE_9GLboolean, -1, BUGLE_GL_ARB_imaging, STATE_HISTOGRAM_PARAMETER },
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info minmax_parameter_state[] =
{
    { STATE_NAME(GL_MINMAX_FORMAT), TYPE_6GLenum, -1, BUGLE_GL_ARB_imaging, STATE_MINMAX_PARAMETER },
    { STATE_NAME(GL_MINMAX_SINK), TYPE_9GLboolean, -1, BUGLE_GL_ARB_imaging, STATE_MINMAX_PARAMETER },
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info vertex_attrib_state[] =
{
#ifdef GL_ARB_vertex_program
    { STATE_NAME_EXT(GL_VERTEX_ATTRIB_ARRAY_ENABLED, _ARB), TYPE_9GLboolean, -1, BUGLE_EXTGROUP_vertex_attrib, STATE_VERTEX_ATTRIB },
    { STATE_NAME_EXT(GL_VERTEX_ATTRIB_ARRAY_SIZE, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_vertex_attrib, STATE_VERTEX_ATTRIB },
    { STATE_NAME_EXT(GL_VERTEX_ATTRIB_ARRAY_STRIDE, _ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_vertex_attrib, STATE_VERTEX_ATTRIB },
    { STATE_NAME_EXT(GL_VERTEX_ATTRIB_ARRAY_TYPE, _ARB), TYPE_6GLenum, -1, BUGLE_EXTGROUP_vertex_attrib, STATE_VERTEX_ATTRIB },
    { STATE_NAME_EXT(GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, _ARB), TYPE_9GLboolean, -1, BUGLE_EXTGROUP_vertex_attrib, STATE_VERTEX_ATTRIB },
    { STATE_NAME_EXT(GL_VERTEX_ATTRIB_ARRAY_POINTER, _ARB), TYPE_P6GLvoid, -1, BUGLE_EXTGROUP_vertex_attrib, STATE_VERTEX_ATTRIB },
    { STATE_NAME_EXT(GL_CURRENT_VERTEX_ATTRIB, _ARB), TYPE_8GLdouble, 4, BUGLE_EXTGROUP_vertex_attrib, STATE_VERTEX_ATTRIB | STATE_SELECT_NON_ZERO },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

/* Note: we keep GL_ARB_shader_objects totally distinct from the shader
 * objects in OpenGL 2.0, because the former uses GLhandleARB and the new
 * object system while OpenGL 2.0 does not.
 */

/* State common to both shaders and programs */
static const state_info object_state[] =
{
#ifdef GL_ARB_shader_objects
    { STATE_NAME(GL_OBJECT_TYPE_ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_shader_objects,  STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_DELETE_STATUS_ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_INFO_LOG_LENGTH_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { "InfoLog", GL_NONE, TYPE_P9GLcharARB, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_INFO_LOG },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info program_object_state[] =
{
#ifdef GL_ARB_shader_objects
    { STATE_NAME(GL_OBJECT_ATTACHED_OBJECTS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_ACTIVE_UNIFORMS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_LINK_STATUS_ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_VALIDATE_STATUS_ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { "Attached", GL_NONE, TYPE_11GLhandleARB, 0, BUGLE_GL_ARB_shader_objects, STATE_ATTACHED_OBJECTS },
#endif
#ifdef GL_ARB_vertex_shader
    { STATE_NAME(GL_OBJECT_ACTIVE_ATTRIBUTES_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_shader, STATE_OBJECT_PARAMETER | STATE_SELECT_VERTEX },
    { STATE_NAME(GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_shader, STATE_OBJECT_PARAMETER | STATE_SELECT_VERTEX },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info shader_object_state[] =
{
#ifdef GL_ARB_shader_objects
    { "ShaderSource", GL_NONE, TYPE_P9GLcharARB, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_SHADER_SOURCE },
    { STATE_NAME(GL_OBJECT_SUBTYPE_ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_COMPILE_STATUS_ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
    { STATE_NAME(GL_OBJECT_SHADER_SOURCE_LENGTH_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_PARAMETER },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info shader_state[] =
{
#ifdef GL_VERSION_2_0
    { STATE_NAME(GL_SHADER_TYPE), TYPE_6GLenum, -1, BUGLE_GL_VERSION_2_0, STATE_SHADER },
    { STATE_NAME(GL_DELETE_STATUS), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_2_0, STATE_SHADER },
    { STATE_NAME(GL_COMPILE_STATUS), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_2_0, STATE_SHADER },
    { "InfoLog", GL_NONE, TYPE_P6GLchar, -1, BUGLE_GL_VERSION_2_0, STATE_SHADER_INFO_LOG },
    { STATE_NAME(GL_INFO_LOG_LENGTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_SHADER },
    { "ShaderSource", GL_NONE, TYPE_P6GLchar, -1, BUGLE_GL_VERSION_2_0, STATE_SHADER_SOURCE },
    { STATE_NAME(GL_SHADER_SOURCE_LENGTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_SHADER },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info program_state[] =
{
#ifdef GL_VERSION_2_0
    { STATE_NAME(GL_DELETE_STATUS), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { STATE_NAME(GL_LINK_STATUS), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { STATE_NAME(GL_VALIDATE_STATUS), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { STATE_NAME(GL_ATTACHED_SHADERS), TYPE_9GLboolean, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { "Attached", GL_NONE, TYPE_6GLuint, 0, BUGLE_GL_VERSION_2_0, STATE_ATTACHED_SHADERS },
    { "InfoLog", GL_NONE, TYPE_P6GLchar, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM_INFO_LOG },
    { STATE_NAME(GL_INFO_LOG_LENGTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { STATE_NAME(GL_ACTIVE_UNIFORMS), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { STATE_NAME(GL_ACTIVE_UNIFORM_MAX_LENGTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { STATE_NAME(GL_ACTIVE_ATTRIBUTES), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM },
    { STATE_NAME(GL_ACTIVE_ATTRIBUTE_MAX_LENGTH), TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_PROGRAM  },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info old_program_object_state[] =
{
#if defined(GL_ARB_vertex_program) || defined(GL_ARB_fragment_program)
    { STATE_NAME(GL_PROGRAM_LENGTH_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_PROGRAM_FORMAT_ARB), TYPE_6GLenum, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_PROGRAM_STRING_ARB), TYPE_PKc, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_PROGRAM_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_fragment_program
    { STATE_NAME(GL_PROGRAM_ALU_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_PROGRAM_TEX_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_PROGRAM_TEX_INDIRECTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
#endif
    { STATE_NAME(GL_PROGRAM_TEMPORARIES_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_PROGRAM_PARAMETERS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_PROGRAM_ATTRIBS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_vertex_program
    { STATE_NAME(GL_PROGRAM_ADDRESS_REGISTERS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_program, STATE_OLD_PROGRAM | STATE_SELECT_VERTEX },
#endif
    { STATE_NAME(GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_fragment_program
    { STATE_NAME(GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
#endif
    { STATE_NAME(GL_PROGRAM_NATIVE_TEMPORARIES_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_PROGRAM_NATIVE_PARAMETERS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_PROGRAM_NATIVE_ATTRIBS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_vertex_program
    { STATE_NAME(GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_program, STATE_OLD_PROGRAM | STATE_SELECT_VERTEX },
#endif
    { STATE_NAME(GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB), TYPE_9GLboolean, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#endif /* GL_ARB_vertex_program || GL_ARB_fragment_program */
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info old_program_state[] =
{
#if defined(GL_ARB_vertex_program) || defined(GL_ARB_fragment_program)
    { STATE_NAME(GL_PROGRAM_BINDING_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_MAX_PROGRAM_ENV_PARAMETERS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_MAX_PROGRAM_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_fragment_program
    { STATE_NAME(GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
#endif
    { STATE_NAME(GL_MAX_PROGRAM_TEMPORARIES_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_MAX_PROGRAM_PARAMETERS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_MAX_PROGRAM_ATTRIBS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_vertex_program
    { STATE_NAME(GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_program, STATE_OLD_PROGRAM | STATE_SELECT_VERTEX },
#endif
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_fragment_program
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_fragment_program, STATE_OLD_PROGRAM | STATE_SELECT_FRAGMENT },
#endif
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB), TYPE_5GLint, -1, BUGLE_EXTGROUP_old_program, STATE_OLD_PROGRAM },
#ifdef GL_ARB_vertex_program
    { STATE_NAME(GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_program, STATE_OLD_PROGRAM | STATE_SELECT_VERTEX },
#endif
#endif /* GL_ARB_vertex_program || GL_ARB_fragment_program */
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info query_state[] =
{
#ifdef GL_ARB_occlusion_query
    { STATE_NAME_EXT(GL_CURRENT_QUERY, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_occlusion_query, STATE_QUERY },
    { STATE_NAME_EXT(GL_QUERY_COUNTER_BITS, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_occlusion_query, STATE_QUERY },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info query_object_state[] =
{
#ifdef GL_ARB_occlusion_query
    { STATE_NAME_EXT(GL_QUERY_RESULT, _ARB), TYPE_6GLuint, -1, BUGLE_GL_ARB_occlusion_query, STATE_QUERY_OBJECT },
    { STATE_NAME_EXT(GL_QUERY_RESULT_AVAILABLE, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_occlusion_query, STATE_QUERY_OBJECT },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

static const state_info buffer_parameter_state[] =
{
#ifdef GL_ARB_vertex_buffer_object
    { STATE_NAME_EXT(GL_BUFFER_SIZE, _ARB), TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_BUFFER_PARAMETER },
    { STATE_NAME_EXT(GL_BUFFER_USAGE, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_BUFFER_PARAMETER },
    { STATE_NAME_EXT(GL_BUFFER_ACCESS, _ARB), TYPE_6GLenum, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_BUFFER_PARAMETER },
    { STATE_NAME_EXT(GL_BUFFER_MAPPED, _ARB), TYPE_9GLboolean, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_BUFFER_PARAMETER },
    { STATE_NAME_EXT(GL_BUFFER_MAP_POINTER, _ARB), TYPE_P6GLvoid, -1, BUGLE_GL_ARB_vertex_buffer_object, STATE_BUFFER_PARAMETER },
#endif
    { NULL, GL_NONE, NULL_TYPE, 0, -1, 0 }
};

typedef struct
{
    const char *name;
    GLenum token;
} enum_pair;

static const enum_pair material_pairs[] =
{
    { STATE_NAME(GL_FRONT) },
    { STATE_NAME(GL_BACK) },
    { NULL, GL_NONE }
};

#ifdef GL_ARB_texture_cube_map
static const enum_pair cube_map_face_pairs[] =
{
    { STATE_NAME_EXT(GL_TEXTURE_CUBE_MAP_POSITIVE_X, _ARB) },
    { STATE_NAME_EXT(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, _ARB) },
    { STATE_NAME_EXT(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, _ARB) },
    { STATE_NAME_EXT(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, _ARB) },
    { STATE_NAME_EXT(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, _ARB) },
    { STATE_NAME_EXT(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, _ARB) },
    { NULL, GL_NONE }
};
#endif

static const enum_pair tex_gen_pairs[] =
{
    { STATE_NAME(GL_S) },
    { STATE_NAME(GL_T) },
    { STATE_NAME(GL_R) },
    { STATE_NAME(GL_Q) },
    { NULL, GL_NONE }
};

static const enum_pair color_table_parameter_pairs[] =
{
    { STATE_NAME(GL_COLOR_TABLE) },
    { STATE_NAME(GL_POST_CONVOLUTION_COLOR_TABLE) },
    { STATE_NAME(GL_POST_COLOR_MATRIX_COLOR_TABLE) },
    { STATE_NAME(GL_PROXY_COLOR_TABLE) },
    { STATE_NAME(GL_PROXY_POST_CONVOLUTION_COLOR_TABLE) },
    { STATE_NAME(GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE) },
    { NULL, GL_NONE }
};

static const enum_pair convolution_parameter_pairs[] =
{
    { STATE_NAME(GL_CONVOLUTION_1D) },
    { STATE_NAME(GL_CONVOLUTION_2D) },
    { NULL, GL_NONE }
};

static const enum_pair histogram_parameter_pairs[] =
{
    { STATE_NAME(GL_HISTOGRAM) },
    { STATE_NAME(GL_PROXY_HISTOGRAM) },
    { NULL, GL_NONE }
};

static const enum_pair minmax_parameter_pairs[] =
{
    { STATE_NAME(GL_MINMAX) },
    { NULL, GL_NONE }
};

static const enum_pair query_pairs[] =
{
#ifdef GL_ARB_occlusion_query
    { STATE_NAME_EXT(GL_SAMPLES_PASSED, _ARB) },
#endif
    { NULL, GL_NONE }
};

/* This exists to simplify the work of gldump.c */
const state_info * const all_state[] =
{
    global_state,
    tex_parameter_state,
    tex_level_parameter_state,
    tex_unit_state,
    tex_gen_state,
    light_state,
    material_state,
    color_table_parameter_state,
    convolution_parameter_state,
    histogram_parameter_state,
    minmax_parameter_state,
    vertex_attrib_state,
    query_state,
    query_object_state,
    buffer_parameter_state,
    object_state,
    shader_object_state,
    program_object_state,
    shader_state,
    program_state,
    old_program_object_state,
    old_program_state,
    NULL
};

typedef struct
{
    void *out;
    budgie_type type;
    int length;
} dump_wrapper_data;

static void dump_wrapper(FILE *f, void *data)
{
    const dump_wrapper_data *w;
    int length;

    w = (const dump_wrapper_data *) data;
    length = w->length;
    budgie_dump_any_type_extended(w->type, w->out, -1, length, NULL, f);
}

static void dump_string_wrapper(FILE *f, void *data)
{
    budgie_dump_string((const char *) data, f);
}

static void get_helper(const glstate *state,
                       GLdouble *d, GLfloat *f, GLint *i,
                       budgie_type *in_type,
                       budgie_function get_double,
                       budgie_function get_float,
                       budgie_function get_int)
{
    if (state->info->type == TYPE_8GLdouble && get_double != NULL_FUNCTION)
    {
        (*(void (*)(GLenum, GLenum, GLdouble *)) budgie_function_table[get_double].real)(state->target, state->info->pname, d);
        *in_type = TYPE_8GLdouble;
    }
    else if ((state->info->type == TYPE_8GLdouble || state->info->type == TYPE_7GLfloat)
        && get_float != NULL_FUNCTION)
    {
        (*(void (*)(GLenum, GLenum, GLfloat *)) budgie_function_table[get_float].real)(state->target, state->info->pname, f);
        *in_type = TYPE_7GLfloat;
    }
    else
    {
        (*(void (*)(GLenum, GLenum, GLint *)) budgie_function_table[get_int].real)(state->target, state->info->pname, i);
        *in_type = TYPE_5GLint;
    }
}

#ifdef GL_ARB_shader_objects
static void uniform_types(GLenum type,
                          budgie_type *in_type,
                          budgie_type *out_type,
                          int *length)
{
    switch (type)
    {
    case GL_FLOAT: *in_type = TYPE_7GLfloat; *out_type = TYPE_7GLfloat; *length = -1; break;
    case GL_FLOAT_VEC2_ARB: *in_type = TYPE_7GLfloat; *out_type = TYPE_7GLfloat; *length = 2; break;
    case GL_FLOAT_VEC3_ARB: *in_type = TYPE_7GLfloat; *out_type = TYPE_7GLfloat; *length = 3; break;
    case GL_FLOAT_VEC4_ARB: *in_type = TYPE_7GLfloat; *out_type = TYPE_7GLfloat; *length = 4; break;
    case GL_INT: *in_type = TYPE_5GLint; *out_type = TYPE_5GLint; *length = -1; break;
    case GL_INT_VEC2_ARB: *in_type = TYPE_5GLint; *out_type = TYPE_5GLint; *length = 2; break;
    case GL_INT_VEC3_ARB: *in_type = TYPE_5GLint; *out_type = TYPE_5GLint; *length = 3; break;
    case GL_INT_VEC4_ARB: *in_type = TYPE_5GLint; *out_type = TYPE_5GLint; *length = 4; break;
    case GL_BOOL_ARB: *in_type = TYPE_5GLint; *out_type = TYPE_9GLboolean; *length = -1; break;
    case GL_BOOL_VEC2_ARB: *in_type = TYPE_5GLint; *out_type = TYPE_9GLboolean; *length = 2; break;
    case GL_BOOL_VEC3_ARB: *in_type = TYPE_5GLint; *out_type = TYPE_9GLboolean; *length = 3; break;
    case GL_BOOL_VEC4_ARB: *in_type = TYPE_5GLint; *out_type = TYPE_9GLboolean; *length = 4; break;
    case GL_FLOAT_MAT2_ARB: *in_type = TYPE_7GLfloat; *out_type = TYPE_7GLfloat; *length = 4; break;
    case GL_FLOAT_MAT3_ARB: *in_type = TYPE_7GLfloat; *out_type = TYPE_7GLfloat; *length = 9; break;
    case GL_FLOAT_MAT4_ARB: *in_type = TYPE_7GLfloat; *out_type = TYPE_7GLfloat; *length = 16; break;
    /* It appears that glext.h version 21 doesn't define these */
#ifdef GL_SAMPLER_1D_ARB
    case GL_SAMPLER_1D_ARB:
    case GL_SAMPLER_2D_ARB:
    case GL_SAMPLER_3D_ARB:
    case GL_SAMPLER_CUBE_ARB:
    case GL_SAMPLER_1D_SHADOW_ARB:
    case GL_SAMPLER_2D_SHADOW_ARB:
    case GL_SAMPLER_2D_RECT_ARB:
    case GL_SAMPLER_2D_RECT_SHADOW_ARB:
        *in_type = TYPE_5GLint; *out_type = TYPE_5GLint; *length = -1; break;
#endif
    default:
        abort();
    }
}
#endif /* GL_ARB_shader_objects */

static int get_total_texture_units(void)
{
    GLint cur = 0, max = 1;

#ifdef GL_ARB_multitexture
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_multitexture))
    {
        CALL_glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
#ifdef GL_ARB_fragment_program
    if (bugle_gl_has_extension_group(BUGLE_EXTGROUP_texunits))
    {
        CALL_glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS_ARB, &cur);
        if (cur > max) max = cur;
        CALL_glGetIntegerv(GL_MAX_TEXTURE_COORDS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
#ifdef GL_ARB_vertex_shader
    if (bugle_gl_has_extension_group(BUGLE_EXTGROUP_vertex_shader))
    {
        CALL_glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
    /* NVIDIA 66.29 on NV20 fail on some of these calls. Clear the error. */
    CALL_glGetError();
    return max;
}

static int get_texture_env_units(void)
{
    GLint ans = 1;

#ifdef GL_ARB_multitexture
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_multitexture))
        CALL_glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &ans);
#endif
    return ans;
}

static int get_texture_image_units(void)
{
    GLint cur = 0, max = 1;

#ifdef GL_ARB_multitexture
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_multitexture))
    {
        CALL_glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
#ifdef GL_ARB_fragment_program
    if (bugle_gl_has_extension_group(BUGLE_EXTGROUP_texunits))
    {
        CALL_glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
#ifdef GL_ARB_vertex_shader
    if (bugle_gl_has_extension_group(BUGLE_EXTGROUP_vertex_shader))
    {
        CALL_glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
    /* NVIDIA 66.29 on NV20 fail on some of these calls. Clear the error. */
    CALL_glGetError();
    return max;
}

static int get_texture_coord_units(void)
{
    GLint cur = 0, max = 1;

#ifdef GL_ARB_multitexture
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_multitexture))
    {
        CALL_glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
#ifdef GL_ARB_fragment_program
    if (bugle_gl_has_extension_group(BUGLE_EXTGROUP_texunits))
    {
        CALL_glGetIntegerv(GL_MAX_TEXTURE_COORDS_ARB, &cur);
        if (cur > max) max = cur;
    }
#endif
    /* NVIDIA 66.29 on NV20 fail on some of these calls. Clear the error. */
    CALL_glGetError();
    return max;
}

char *bugle_state_get_string(const glstate *state)
{
    GLdouble d[16];
    GLfloat f[16];
    GLint i[16];
    GLuint ui[16];
    GLboolean b[16];
    GLvoid *p[16];
    GLpolygonstipple stipple;
#ifdef GL_ARB_shader_objects
    GLhandleARB h[16];
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ARB_shader_objects)
    GLsizei length;
    GLint max_length;
#endif
    void *in;
    budgie_type in_type, out_type;
    int in_length;
    dump_wrapper_data wrapper;
    char *str = NULL;

    GLint old_texture, old_buffer, old_program;
    GLint old_unit, old_client_unit;
    bool flag_active_texture = false;
    GLenum pname;

    if (!state->info) return NULL;
    if (state->info->pname) pname = state->info->pname;
    else pname = state->target;
    in_type = state->info->type;
    in_length = state->info->length;
    out_type = state->info->type;
    wrapper.out = NULL; /* Set to non-NULL if manual conversion */

    if (CALL_glGetError())
    {
        fprintf(stderr, "Warning: GL error preceeding %s\n", state->name ? state->name : "");
        fprintf(stderr, "target = %s binding = %s face = %s level = %d object = %u\n",
                bugle_gl_enum_to_token(state->target),
                bugle_gl_enum_to_token(state->binding),
                bugle_gl_enum_to_token(state->face),
                (int) state->level,
                (unsigned int) state->object);
    }

#ifdef GL_ARB_multitexture
    if ((state->info->flags & STATE_MULTIPLEX_ACTIVE_TEXTURE)
        && bugle_gl_has_extension_group(BUGLE_GL_ARB_multitexture))
    {
        CALL_glGetIntegerv(GL_ACTIVE_TEXTURE_ARB, &old_unit);
        CALL_glGetIntegerv(GL_CLIENT_ACTIVE_TEXTURE_ARB, &old_client_unit);
#ifdef GL_VERSION_1_3
        if (bugle_gl_has_extension(BUGLE_GL_VERSION_1_3))
        {
            CALL_glActiveTexture(state->unit);
            if (state->unit > get_texture_coord_units())
                CALL_glClientActiveTexture(state->unit);
        }
        else
#endif
        {
            CALL_glActiveTextureARB(state->unit);
            if (state->unit > get_texture_coord_units())
                CALL_glClientActiveTextureARB(state->unit);
        }
        flag_active_texture = true;
    }
#endif /* GL_ARB_multitexture */
#ifdef GL_ARB_vertex_buffer_object
    if (state->info->flags & STATE_MULTIPLEX_BIND_BUFFER)
    {
        CALL_glGetIntegerv(GL_ARRAY_BUFFER_BINDING_ARB, &old_buffer);
#ifdef GL_VERSION_1_5
        if (bugle_gl_has_extension(BUGLE_GL_VERSION_1_5))
        {
            CALL_glBindBuffer(GL_ARRAY_BUFFER_ARB, state->object);
        }
        else
#endif
        {
            CALL_glBindBufferARB(GL_ARRAY_BUFFER_ARB, state->object);
        }
    }
#endif /* GL_ARB_vertex_buffer_object */
#if defined(GL_ARB_vertex_program) || defined(GL_ARB_fragment_program)
    if (state->info->flags & STATE_MULTIPLEX_BIND_PROGRAM)
    {
        CALL_glGetProgramivARB(state->target, GL_PROGRAM_BINDING_ARB, &old_program);
        CALL_glBindProgramARB(state->target, state->object);
    }
#endif
    if ((state->info->flags & STATE_MULTIPLEX_BIND_TEXTURE)
        && state->binding) /* binding of 0 means a proxy texture */
    {
        CALL_glGetIntegerv(state->binding, &old_texture);
        CALL_glBindTexture(state->target, state->object);
    }

    switch (state->info->flags & STATE_MODE_MASK)
    {
    case STATE_MODE_GLOBAL:
        if (state->info->type == TYPE_PKc)
        {
            str = (char *) CALL_glGetString(pname);
            if (str) str = bugle_strdup(str);
            else str = bugle_strdup("(nil)");
        }
        else if (state->info->type == TYPE_9GLboolean)
            CALL_glGetBooleanv(pname, b);
        else if (state->info->type == TYPE_P6GLvoid)
            CALL_glGetPointerv(pname, p);
        else if (state->info->type == TYPE_8GLdouble)
            CALL_glGetDoublev(pname, d);
        else if (state->info->type == TYPE_7GLfloat)
            CALL_glGetFloatv(pname, f);
        else
        {
            CALL_glGetIntegerv(pname, i);
            in_type = TYPE_5GLint;
        }
        break;
    case STATE_MODE_ENABLED:
        b[0] = CALL_glIsEnabled(pname);
        in_type = TYPE_9GLboolean;
        break;
    case STATE_MODE_TEXTURE_ENV:
    case STATE_MODE_TEXTURE_FILTER_CONTROL:
    case STATE_MODE_POINT_SPRITE:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetTexEnvfv, FUNC_glGetTexEnviv);
        break;
    case STATE_MODE_TEX_PARAMETER:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetTexParameterfv, FUNC_glGetTexParameteriv);
        break;
    case STATE_MODE_TEX_LEVEL_PARAMETER:
        if (state->info->type == TYPE_8GLdouble || state->info->type == TYPE_7GLfloat)
        {
            CALL_glGetTexLevelParameterfv(state->face, state->level, pname, f);
            in_type = TYPE_7GLfloat;
        }
        else
        {
            CALL_glGetTexLevelParameteriv(state->face, state->level, pname, i);
            in_type = TYPE_5GLint;
        }
        break;
    case STATE_MODE_TEX_GEN:
        get_helper(state, d, f, i, &in_type, FUNC_glGetTexGendv,
                   FUNC_glGetTexGenfv, FUNC_glGetTexGeniv);
        break;
    case STATE_MODE_LIGHT:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetLightfv, FUNC_glGetLightiv);
        break;
    case STATE_MODE_MATERIAL:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetMaterialfv, FUNC_glGetMaterialiv);
        break;
    case STATE_MODE_CLIP_PLANE:
        CALL_glGetClipPlane(state->target, d);
        in_type = TYPE_8GLdouble;
        break;
    case STATE_MODE_POLYGON_STIPPLE:
        CALL_glGetPolygonStipple((GLubyte *) stipple);
        break;
    case STATE_MODE_COLOR_TABLE_PARAMETER:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetColorTableParameterfv, FUNC_glGetColorTableParameteriv);
        break;
    case STATE_MODE_CONVOLUTION_PARAMETER:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetConvolutionParameterfv, FUNC_glGetConvolutionParameteriv);
        break;
    case STATE_MODE_HISTOGRAM_PARAMETER:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetHistogramParameterfv, FUNC_glGetHistogramParameteriv);
        break;
    case STATE_MODE_MINMAX_PARAMETER:
        get_helper(state, d, f, i, &in_type, NULL_FUNCTION,
                   FUNC_glGetMinmaxParameterfv, FUNC_glGetMinmaxParameteriv);
        break;
#ifdef GL_ARB_vertex_program
    case STATE_MODE_VERTEX_ATTRIB:
        if (state->info->type == TYPE_P6GLvoid)
            CALL_glGetVertexAttribPointervARB(state->object, pname, p);
        else if (state->info->type == TYPE_8GLdouble)
            CALL_glGetVertexAttribdvARB(state->object, pname, d);
        else if (state->info->type == TYPE_7GLfloat)
            CALL_glGetVertexAttribfvARB(state->object, pname, f);
        else
        {
            CALL_glGetVertexAttribivARB(state->object, pname, i);
            in_type = TYPE_5GLint;
        }
        break;
#endif
#ifdef GL_ARB_occlusion_query
    case STATE_MODE_QUERY:
        CALL_glGetQueryivARB(state->target, pname, i);
        in_type = TYPE_5GLint;
        break;
    case STATE_MODE_QUERY_OBJECT:
        if (state->info->type == TYPE_6GLuint)
            CALL_glGetQueryObjectuivARB(state->object, pname, ui);
        else
        {
            CALL_glGetQueryObjectivARB(state->object, pname, i);
            in_type = TYPE_5GLint;
        }
        break;
#endif
#ifdef GL_ARB_vertex_buffer_object
    case STATE_MODE_BUFFER_PARAMETER:
        if (state->info->type == TYPE_P6GLvoid)
            CALL_glGetBufferPointervARB(GL_ARRAY_BUFFER_ARB, pname, p);
        else
        {
            CALL_glGetBufferParameterivARB(GL_ARRAY_BUFFER_ARB, pname, i);
            in_type = TYPE_5GLint;
        }
        break;
#endif
#ifdef GL_ARB_shader_objects
    case STATE_MODE_OBJECT_PARAMETER:
        if (state->info->type == TYPE_8GLdouble || state->info->type == TYPE_7GLfloat)
        {
            CALL_glGetObjectParameterfvARB(state->object, pname, f);
            in_type = TYPE_7GLfloat;
        }
        else
        {
            CALL_glGetObjectParameterivARB(state->object, pname, i);
            in_type = TYPE_5GLint;
        }
        break;
    case STATE_MODE_OBJECT_INFO_LOG:
        CALL_glGetObjectParameterivARB(state->object, GL_OBJECT_INFO_LOG_LENGTH_ARB, &max_length);
        str = bugle_malloc(max_length * sizeof(GLcharARB));
        CALL_glGetInfoLogARB(state->object, max_length, &length, (GLcharARB *) str);
        break;
    case STATE_MODE_OBJECT_SHADER_SOURCE:
        CALL_glGetObjectParameterivARB(state->object, GL_OBJECT_SHADER_SOURCE_LENGTH_ARB, &max_length);
        str = bugle_malloc(max_length * sizeof(GLcharARB));
        CALL_glGetShaderSourceARB(state->object, max_length, &length, (GLcharARB *) str);
        break;
    case STATE_MODE_OBJECT_UNIFORM:
        {
            GLsizei size;
            GLenum type;

            CALL_glGetActiveUniformARB(state->object, state->level, 0, NULL,
                                       &size, &type, NULL);
            uniform_types(type, &in_type, &out_type, &in_length);
            if (in_type == TYPE_7GLfloat)
                CALL_glGetUniformfvARB(state->object, state->level, f);
            else
                CALL_glGetUniformivARB(state->object, state->level, i);
        }
        break;
    case STATE_MODE_OBJECT_ATTRIB_LOCATION:
        i[0] = CALL_glGetAttribLocationARB(state->object, state->name);
        break;
    case STATE_MODE_ATTACHED_OBJECTS:
        {
            GLhandleARB *attached;

            CALL_glGetObjectParameterivARB(state->object, GL_OBJECT_ATTACHED_OBJECTS_ARB, &max_length);
            attached = bugle_malloc(max_length * sizeof(GLhandleARB));
            CALL_glGetAttachedObjectsARB(state->object, max_length, NULL, attached);
            wrapper.out = attached;
            wrapper.length = max_length;
            wrapper.type = TYPE_11GLhandleARB;
        }
        break;
#endif
#ifdef GL_VERSION_2_0
    case STATE_MODE_SHADER:
        CALL_glGetShaderiv(state->object, pname, i);
        in_type = TYPE_5GLint;
        break;
    case STATE_MODE_PROGRAM:
        CALL_glGetProgramiv(state->object, pname, i);
        in_type = TYPE_5GLint;
        break;
    case STATE_MODE_SHADER_INFO_LOG:
        CALL_glGetShaderiv(state->object, GL_INFO_LOG_LENGTH, &max_length);
        str = bugle_malloc(max_length * sizeof(GLchar));
        CALL_glGetShaderInfoLog(state->object, max_length, &length, (GLchar *) str);
        break;
    case STATE_MODE_PROGRAM_INFO_LOG:
        CALL_glGetProgramiv(state->object, GL_INFO_LOG_LENGTH, &max_length);
        str = bugle_malloc(max_length * sizeof(GLchar));
        CALL_glGetProgramInfoLog(state->object, max_length, &length, (GLchar *) str);
        break;
    case STATE_MODE_SHADER_SOURCE:
        CALL_glGetShaderiv(state->object, GL_SHADER_SOURCE_LENGTH, &max_length);
        str = bugle_malloc(max_length * sizeof(GLcharARB));
        CALL_glGetShaderSource(state->object, max_length, &length, (GLchar *) str);
        break;
    case STATE_MODE_UNIFORM:
        {
            GLsizei size;
            GLenum type;

            CALL_glGetActiveUniform(state->object, state->level, 0, NULL,
                                    &size, &type, NULL);
            uniform_types(type, &in_type, &out_type, &in_length);
            if (in_type == TYPE_7GLfloat)
                CALL_glGetUniformfv(state->object, state->level, f);
            else
                CALL_glGetUniformiv(state->object, state->level, i);
        }
        break;
    case STATE_MODE_ATTRIB_LOCATION:
        i[0] = CALL_glGetAttribLocation(state->object, state->name);
        break;
    case STATE_MODE_ATTACHED_SHADERS:
        {
            GLuint *attached;

            CALL_glGetProgramiv(state->object, GL_ATTACHED_SHADERS, &max_length);
            attached = bugle_malloc(max_length * sizeof(GLuint));
            CALL_glGetAttachedShaders(state->object, max_length, NULL, attached);
            wrapper.out = attached;
            wrapper.length = max_length;
            wrapper.type = TYPE_6GLuint;
        }
        break;
#endif
#if defined(GL_ARB_vertex_program) || defined(GL_ARB_fragment_program)
    case STATE_MODE_OLD_PROGRAM:
        if (state->info->type == TYPE_PKc)
        {
            CALL_glGetProgramivARB(state->target, GL_PROGRAM_LENGTH_ARB, i);
            str = bugle_malloc((i[0] + 1) * sizeof(char));
            str[i[0]] = '\0';
            CALL_glGetProgramStringARB(state->target, pname, str);
        }
        else
        {
            CALL_glGetProgramivARB(state->target, pname, i);
            in_type = TYPE_5GLint;
        }
        break;
    case STATE_MODE_PROGRAM_ENV_PARAMETER:
        CALL_glGetProgramEnvParameterdvARB(state->target, state->level, d);
        in_type = TYPE_8GLdouble;
        break;
    case STATE_MODE_PROGRAM_LOCAL_PARAMETER:
        CALL_glGetProgramLocalParameterdvARB(state->target, state->level, d);
        in_type = TYPE_8GLdouble;
        break;
#endif
#ifdef GL_ARB_texture_compression
    case STATE_MODE_COMPRESSED_TEXTURE_FORMATS:
        {
            GLint count;
            GLint *formats;
            GLenum *out;

            CALL_glGetIntegerv(GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB, &count);
            formats = bugle_malloc(count * sizeof(GLint));
            out = bugle_malloc(count * sizeof(GLenum));
            CALL_glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS_ARB, formats);
            budgie_type_convert(out, TYPE_6GLenum, formats, TYPE_5GLint, count);
            wrapper.out = out;
            wrapper.length = count;
            wrapper.type = TYPE_6GLenum;
            free(formats);
        }
        break;
#endif
    default:
        abort();
    }

#ifdef GL_ARB_multitexture
    if (flag_active_texture)
    {
#ifdef GL_VERSION_1_3
        if (bugle_gl_has_extension(BUGLE_GL_VERSION_1_3))
        {
            CALL_glActiveTexture(old_unit);
            if (state->unit > get_texture_coord_units())
                CALL_glClientActiveTexture(old_client_unit);
        }
        else
#endif
        {
            CALL_glActiveTextureARB(old_unit);
            if (state->unit > get_texture_coord_units())
                CALL_glClientActiveTextureARB(old_client_unit);
        }
    }
#endif /* GL_ARB_multitexture */
#ifdef GL_ARB_vertex_buffer_object
    if (state->info->flags & STATE_MULTIPLEX_BIND_BUFFER)
    {
#ifdef GL_VERSION_1_5
        if (bugle_gl_has_extension(BUGLE_GL_VERSION_1_5))
        {
            CALL_glBindBuffer(GL_ARRAY_BUFFER_ARB, old_buffer);
        }
        else
#endif
        {
            CALL_glBindBufferARB(GL_ARRAY_BUFFER_ARB, old_buffer);
        }
    }
#endif /* GL_ARB_vertex_buffer_object */
#if defined(GL_ARB_vertex_program) || defined(GL_ARB_fragment_program)
    if (state->info->flags & STATE_MULTIPLEX_BIND_PROGRAM)
        CALL_glBindProgramARB(state->target, old_program);
#endif
    if ((state->info->flags & STATE_MULTIPLEX_BIND_TEXTURE)
        && state->binding)
        CALL_glBindTexture(state->target, old_texture);

    if (CALL_glGetError())
    {
        if (state->name)
            fprintf(stderr, "GL error generated by state %s\n", state->name);
        else
            fprintf(stderr, "GL error generated by anonymous state\n");
        return bugle_strdup("<GL error>");
    }

    if (str)
    {
        char *ans;

        ans = budgie_string_io(dump_string_wrapper, str);
        free(str);
        return ans;
    }

    if (!wrapper.out)
    {
        switch (in_type)
        {
        case TYPE_8GLdouble: in = d; break;
        case TYPE_7GLfloat: in = f; break;
        case TYPE_5GLint: in = i; break;
        case TYPE_6GLuint: in = ui; break;
#ifdef GL_ARB_shader_objects
        /* FIXME: we don't actually use this atm. We need some way to
         * call exactly one of glGetIntegerv on GL_CURRENT_PROGRAM_ARB
         * or glGetHandle on GL_PROGRAM_OBJECT_ARB.
         */
        case TYPE_11GLhandleARB: in = h; break;
#endif
        case TYPE_9GLboolean: in = b; break;
        case TYPE_P6GLvoid: in = p; break;
        case TYPE_16GLpolygonstipple: in = stipple; break;
        default: abort();
        }

        wrapper.out = bugle_malloc(abs(in_length) * budgie_type_table[out_type].size);
        wrapper.type = out_type;
        wrapper.length = in_length;
        budgie_type_convert(wrapper.out, wrapper.type, in, in_type, abs(wrapper.length));
    }
    str = budgie_string_io(dump_wrapper, &wrapper);
    free(wrapper.out);
    return str;
}

void bugle_state_get_children(const glstate *self, bugle_linked_list *children)
{
    if (self->spawn_children) (*self->spawn_children)(self, children);
    else bugle_list_init(children, true);
}

void bugle_state_clear(glstate *self)
{
    if (self->name) free(self->name);
}

/* All the make functions _append_ nodes to children. That means you have
 * to initialise the list yourself.
 */
static void make_leaves_conditional(const glstate *self, const state_info *table,
                                    uint32_t flags, unsigned int mask,
                                    bugle_linked_list *children)
{
    const char *version;
    glstate *child;
    const state_info *info;

    version = (const char *) CALL_glGetString(GL_VERSION);
    for (info = table; info->name; info++)
    {
        if ((info->flags & mask) == flags
            && (bugle_gl_has_extension_group(info->extensions)))
        {
            child = bugle_malloc(sizeof(glstate));
            *child = *self; /* copies contextual info */
            child->name = bugle_strdup(info->name);
            child->info = info;
            child->spawn_children = NULL;
            bugle_list_append(children, child);
        }
    }
}

static void make_leaves(const glstate *self, const state_info *table,
                        bugle_linked_list *children)
{
    make_leaves_conditional(self, table, 0, 0, children);
}

static void make_fixed(const glstate *self,
                       const enum_pair *pairs,
                       size_t offset,
                       void (*spawn)(const glstate *, bugle_linked_list *),
                       bugle_linked_list *children)
{
    size_t i;
    glstate *child;

    for (i = 0; pairs[i].name; i++)
    {
        child = bugle_malloc(sizeof(glstate));
        *child = *self;
        child->info = NULL;
        child->name = bugle_strdup(pairs[i].name);
        *(GLenum *) (((char *) child) + offset) = pairs[i].token;
        child->spawn_children = spawn;
        bugle_list_append(children, child);
    }
}

static void make_counted(const glstate *self,
                         GLint count,
                         const char *format,
                         GLenum base,
                         size_t offset,
                         void (*spawn)(const glstate *, bugle_linked_list *),
                         const state_info *info,
                         bugle_linked_list *children)
{
    GLint i;
    glstate *child;

    for (i = 0; i < count; i++)
    {
        child = bugle_malloc(sizeof(glstate));
        *child = *self;
        child->info = info;
        bugle_asprintf(&child->name, format, (unsigned long) i);
        *(GLenum *) (((char *) child) + offset) = base + i;
        child->spawn_children = spawn;
        bugle_list_append(children, child);
    }
}

static void make_object(const glstate *self,
                        GLenum target,
                        const char *format,
                        gl_handle id,
                        void (*spawn)(const glstate *, bugle_linked_list *),
                        const state_info *info,
                        bugle_linked_list *children)
{
    glstate *child;

    child = bugle_malloc(sizeof(glstate));
    *child = *self;
    child->target = target;
    child->info = info;
    bugle_asprintf(&child->name, format, (unsigned long) id);
    child->object = id;
    child->spawn_children = spawn;
    bugle_list_append(children, child);
}

typedef struct
{
    const glstate *self;
    GLenum target;
    const char *format;
    void (*spawn_children)(const glstate *, bugle_linked_list *);
    state_info *info;
    bugle_linked_list *children;
} make_objects_data;

static void make_objects_walker(gl_handle object,
                                GLenum target,
                                void *vdata)
{
    const make_objects_data *data;

    data = (const make_objects_data *) vdata;
    if (data->target != GL_NONE && target != GL_NONE
        && target != data->target) return;
    make_object(data->self, target, data->format, object, data->spawn_children,
                data->info, data->children);
}

static void make_objects(const glstate *self,
                         bugle_trackobjects_type type,
                         GLenum target,
                         bool add_zero,
                         const char *format,
                         void (*spawn_children)(const glstate *, bugle_linked_list *),
                         state_info *info,
                         bugle_linked_list *children)
{
    make_objects_data data;

    data.self = self;
    data.target = target;
    data.format = format;
    data.spawn_children = spawn_children;
    data.info = info;
    data.children = children;

    if (add_zero)
        make_object(self, target, format, 0, spawn_children, info, children);
    bugle_trackobjects_walk(type, make_objects_walker, &data);
}

static void spawn_children_tex_target(const glstate *, bugle_linked_list *);
static void spawn_children_tex_level_parameter(const glstate *, bugle_linked_list *);

static void make_target(const glstate *self,
                        const char *name,
                        GLenum target,
                        GLenum binding,
                        void (*spawn_children)(const glstate *, bugle_linked_list *),
                        const state_info *info,
                        bugle_linked_list *children)
{
    glstate *child;

    child = bugle_malloc(sizeof(glstate));
    *child = *self;
    child->name = bugle_strdup(name);
    child->target = target;
    child->face = target;   /* Changed at next level for cube maps */
    child->binding = binding;
    child->spawn_children = spawn_children;
    child->info = info;
    bugle_list_append(children, child);
}

static void make_tex_levels(const glstate *self,
                            bugle_linked_list *children)
{
    GLint base, max, i;
    glstate *child;
    GLint old;

    if (self->binding)
    {
        CALL_glGetIntegerv(self->binding, &old);
        CALL_glBindTexture(self->target, self->object);
    }
    base = 0;
    max = 1000;
#ifdef GL_SGIS_texture_lod
    if (self->binding && bugle_gl_has_extension_group(GL_SGIS_texture_lod)) /* No parameters for proxy textures */
    {
        CALL_glGetTexParameteriv(self->target, GL_TEXTURE_BASE_LEVEL_SGIS, &base);
        CALL_glGetTexParameteriv(self->target, GL_TEXTURE_MAX_LEVEL_SGIS, &max);
    }
#endif

    for (i = base; i <= base + max; i++)
    {
        GLint width;
        CALL_glGetTexLevelParameteriv(self->face, i, GL_TEXTURE_WIDTH, &width);
        if (width <= 0) break;

        child = bugle_malloc(sizeof(glstate));
        *child = *self;
        bugle_asprintf(&child->name, "level[%lu]", (unsigned long) i);
        child->info = NULL;
        child->level = i;
        child->spawn_children = spawn_children_tex_level_parameter;
        bugle_list_append(children, child);
    }

    if (self->binding) CALL_glBindTexture(self->target, old);
}

static void spawn_children_tex_gen(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, tex_gen_state, children);
}

static void spawn_children_tex_unit(const glstate *self, bugle_linked_list *children)
{
    bugle_list_node *i;
    glstate *child;
    uint32_t mask = 0;

    bugle_list_init(children, true);
#ifdef GL_ARB_multitexture
    if (self->unit >= GL_TEXTURE0_ARB + get_texture_env_units())
        mask |= STATE_SELECT_TEXTURE_ENV;
    if (self->unit >= GL_TEXTURE0_ARB + get_texture_coord_units())
        mask |= STATE_SELECT_TEXTURE_COORD;
    if (self->unit >= GL_TEXTURE0_ARB + get_texture_image_units())
        mask |= STATE_SELECT_TEXTURE_IMAGE;
#endif
    make_leaves_conditional(self, tex_unit_state, 0, mask, children);
    for (i = bugle_list_head(children); i; i = bugle_list_next(i))
    {
        child = (glstate *) bugle_list_data(i);
        switch (child->info->flags & STATE_MODE_MASK)
        {
        case STATE_MODE_TEXTURE_ENV:
            child->target = GL_TEXTURE_ENV;
            break;
#ifdef GL_EXT_texture_lod_bias
        case STATE_MODE_TEXTURE_FILTER_CONTROL:
            child->target = GL_TEXTURE_FILTER_CONTROL;
            break;
#endif
#ifdef GL_ARB_point_sprite
        case STATE_MODE_POINT_SPRITE:
            child->target = GL_POINT_SPRITE_ARB;
            break;
#endif
        }
    }

    if (!(mask & STATE_SELECT_TEXTURE_COORD))
        make_fixed(self, tex_gen_pairs, offsetof(glstate, target),
                   spawn_children_tex_gen, children);
}

/* Returns a mask of flags not to select from state tables, based on the
 * dimension of the target.
 */
static uint32_t texture_mask(GLenum target)
{
    uint32_t mask = 0;

    switch (target)
    {
    case GL_PROXY_TEXTURE_1D: mask |= STATE_SELECT_NO_PROXY; /* Fall through */
    case GL_TEXTURE_1D: mask |= STATE_SELECT_NO_1D; break;
    case GL_PROXY_TEXTURE_2D: mask |= STATE_SELECT_NO_PROXY; /* Fall through */
    case GL_TEXTURE_2D: mask |= STATE_SELECT_NO_2D; break;
#ifdef GL_ARB_texture_cube_map
    case GL_PROXY_TEXTURE_CUBE_MAP_ARB: mask |= STATE_SELECT_NO_PROXY; /* Fall through */
    case GL_TEXTURE_CUBE_MAP_ARB: mask |= STATE_SELECT_NO_2D; break;
#endif
#ifdef GL_NV_texture_rectangle
    case GL_PROXY_TEXTURE_RECTANGLE_NV: mask |= STATE_SELECT_NO_PROXY; /* Fall through */
    case GL_TEXTURE_RECTANGLE_NV: mask |= STATE_SELECT_NO_2D; break;
#endif
#ifdef GL_EXT_texture3D
    case GL_PROXY_TEXTURE_3D_EXT: mask |= STATE_SELECT_NO_PROXY; break;
#endif
    }
    return mask;
}

static void spawn_children_tex_level_parameter(const glstate *self, bugle_linked_list *children)
{
    uint32_t mask = STATE_SELECT_COMPRESSED;

#ifdef GL_ARB_texture_compression
    if (!(mask & STATE_SELECT_NO_PROXY)
        && bugle_gl_has_extension_group(BUGLE_GL_ARB_texture_compression)
        && bugle_begin_internal_render())
    {
        GLint old, compressed;

        if (self->binding)
        {
            CALL_glGetIntegerv(self->binding, &old);
            CALL_glBindTexture(self->target, self->object);
        }
        CALL_glGetTexLevelParameteriv(self->face, self->level, GL_TEXTURE_COMPRESSED_ARB, &compressed);
        if (compressed) mask &= ~STATE_SELECT_COMPRESSED;
        if (self->binding) CALL_glBindTexture(self->target, old);
        bugle_end_internal_render("spawn_children_tex_level_parameter", true);
    }
#endif
    bugle_list_init(children, true);
    make_leaves_conditional(self, tex_level_parameter_state, 0,
                            mask | texture_mask(self->target), children);
}

#ifdef GL_ARB_texture_cube_map
static void spawn_children_cube_map_faces(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_tex_levels(self, children);
}
#endif

static void spawn_children_tex_parameter(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    if (self->binding) /* Zero indicates a proxy, which have no texture parameter state */
        make_leaves_conditional(self, tex_parameter_state, 0,
                                texture_mask(self->target), children);
#ifdef GL_ARB_texture_cube_map
    if (self->target == GL_TEXTURE_CUBE_MAP_ARB)
    {
        make_fixed(self, cube_map_face_pairs, offsetof(glstate, face),
                   spawn_children_cube_map_faces, children);
        return;
    }
#endif
    make_tex_levels(self, children);
}

static void spawn_children_tex_target(const glstate *self, bugle_linked_list *children)
{
    if (self->binding) /* Zero here indicates a proxy target */
    {
        bugle_list_init(children, true);
        make_objects(self, BUGLE_TRACKOBJECTS_TEXTURE, self->target, true, "%lu",
                     spawn_children_tex_parameter, NULL, children);
    }
    else
        spawn_children_tex_parameter(self, children);
}

static void spawn_children_light(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, light_state, children);
}

static void spawn_children_material(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, material_state, children);
}

static void spawn_children_color_table_parameter(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    switch (self->target)
    {
    case GL_COLOR_TABLE:
    case GL_POST_CONVOLUTION_COLOR_TABLE:
    case GL_POST_COLOR_MATRIX_COLOR_TABLE:
        make_leaves(self, color_table_parameter_state, children);
        break;
    case GL_PROXY_COLOR_TABLE:
    case GL_PROXY_POST_CONVOLUTION_COLOR_TABLE:
    case GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE:
        make_leaves_conditional(self, color_table_parameter_state, 0,
                                STATE_SELECT_NO_PROXY, children);
        break;
    }
}

static void spawn_children_convolution_parameter(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    if (self->target == GL_CONVOLUTION_1D)
        make_leaves_conditional(self, convolution_parameter_state,
                                0, STATE_SELECT_NO_1D, children);
    else
        make_leaves(self, convolution_parameter_state, children);
}

static void spawn_children_histogram_parameter(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, histogram_parameter_state, children);
}

static void spawn_children_minmax_parameter(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, minmax_parameter_state, children);
}

static void spawn_children_vertex_attrib(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves_conditional(self, vertex_attrib_state,
                            0,
                            (self->object == 0) ? STATE_SELECT_NON_ZERO : 0,
                            children);
}

static void spawn_children_query(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, query_state, children);
}

static void spawn_children_query_object(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, query_object_state, children);
}

static void spawn_children_buffer_parameter(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, buffer_parameter_state, children);
}

#ifdef GL_ARB_shader_objects
static void spawn_children_shader_object(const glstate *self, bugle_linked_list *children)
{
    uint32_t mask = STATE_SELECT_VERTEX;

    bugle_list_init(children, true);
#ifdef GL_ARB_vertex_shader
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_vertex_shader)) mask = 0;
#endif
    make_leaves_conditional(self, object_state, 0, mask, children);
    make_leaves_conditional(self, shader_object_state, 0, mask, children);
}

static void spawn_children_program_object(const glstate *self, bugle_linked_list *children)
{
    uint32_t mask = STATE_SELECT_VERTEX;
    GLint i, count, max, type;
    GLsizei length, size;
    glstate *child;
    static const state_info object_uniform_state =
    {
        NULL, GL_NONE, NULL_TYPE, -1, BUGLE_GL_ARB_shader_objects, STATE_OBJECT_UNIFORM
    };
    static const state_info object_attrib_state =
    {
        NULL, GL_NONE, TYPE_5GLint, -1, BUGLE_GL_ARB_vertex_shader, STATE_OBJECT_ATTRIB_LOCATION
    };

    bugle_list_init(children, true);
#ifdef GL_ARB_vertex_shader
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_vertex_shader)) mask = 0;
#endif
    make_leaves(self, object_state, children);
    make_leaves(self, program_object_state, children);

    CALL_glGetObjectParameterivARB(self->object, GL_OBJECT_ACTIVE_UNIFORMS_ARB,
                                   &count);
    CALL_glGetObjectParameterivARB(self->object, GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB,
                                   &max);
    for (i = 0; i < count; i++)
    {
        child = bugle_malloc(sizeof(glstate));
        *child = *self;
        child->spawn_children = NULL;
        child->info = &object_uniform_state;
        child->name = bugle_malloc(sizeof(GLcharARB) * (max + 1));
        child->name[0] = '\0'; /* sanity, in case the query borks */
        child->level = i;
        CALL_glGetActiveUniformARB(self->object, i, max, &length, &size,
                                   &type, child->name);
        if (length)
        {
            /* Check for built-in state, which is returned by glGetActiveUniformARB
             * but cannot be queried.
             */
            child->level = CALL_glGetUniformLocationARB(self->object, child->name);
            if (child->level == -1) length = 0;
        }
        if (length) bugle_list_append(children, child);
        else free(child->name); /* failed query */
    }

#ifdef GL_ARB_vertex_shader
    if (bugle_gl_has_extension(BUGLE_GL_ARB_vertex_shader))
    {
        CALL_glGetObjectParameterivARB(self->object, GL_OBJECT_ACTIVE_ATTRIBUTES_ARB,
                                       &count);
        CALL_glGetObjectParameterivARB(self->object, GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB,
                                       &max);

        for (i = 0; i < count; i++)
        {
            child = bugle_malloc(sizeof(glstate));
            *child = *self;
            child->spawn_children = NULL;
            child->info = &object_attrib_state;
            child->name = bugle_malloc(sizeof(GLcharARB) * (max + 1));
            child->name[0] = '\0';
            child->level = i;
            CALL_glGetActiveAttribARB(self->object, i, max, &length, &size,
                                      &type, child->name);
            if (length) bugle_list_append(children, child);
            else free(child->name);
        }
    }
#endif
}
#endif /* GL_ARB_shader_objects */

#ifdef GL_VERSION_2_0
static void spawn_children_shader(const glstate *self, bugle_linked_list *children)
{
    bugle_list_init(children, true);
    make_leaves(self, shader_state, children);
}

static void spawn_children_program(const glstate *self, bugle_linked_list *children)
{
    static const state_info program_uniform_state =
    {
        NULL, GL_NONE, NULL_TYPE, -1, BUGLE_GL_VERSION_2_0, STATE_UNIFORM
    };
    static const state_info program_attrib_state =
    {
        NULL, GL_NONE, TYPE_5GLint, -1, BUGLE_GL_VERSION_2_0, STATE_ATTRIB_LOCATION
    };
    GLint i, count, max, type;
    GLsizei length, size;
    glstate *child;

    bugle_list_init(children, true);
    make_leaves(self, shader_state, children);

    CALL_glGetProgramiv(self->object, GL_ACTIVE_UNIFORMS, &count);
    CALL_glGetProgramiv(self->object, GL_ACTIVE_UNIFORM_MAX_LENGTH, &max);
    for (i = 0; i < count; i++)
    {
        child = bugle_malloc(sizeof(glstate));
        *child = *self;
        child->spawn_children = NULL;
        child->info = &program_uniform_state;
        child->name = bugle_malloc(sizeof(GLchar) * (max + 1));
        child->name[0] = '\0'; /* sanity, in case the query borks */
        child->level = i;
        CALL_glGetActiveUniform(self->object, i, max, &length, &size,
                                &type, child->name);
        if (length)
        {
            /* Check for built-in state, which is returned by glGetActiveUniform
             * but cannot be queried.
             */
            child->level = CALL_glGetUniformLocation(self->object, child->name);
            if (child->level == -1) length = 0;
        }
        if (length) bugle_list_append(children, child);
        else free(child->name); /* failed query */
    }

    CALL_glGetProgramiv(self->object, GL_ACTIVE_ATTRIBUTES, &count);
    CALL_glGetProgramiv(self->object, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &max);

    for (i = 0; i < count; i++)
    {
        child = bugle_malloc(sizeof(glstate));
        *child = *self;
        child->spawn_children = NULL;
        child->info = &program_attrib_state;
        child->name = bugle_malloc(sizeof(GLchar) * (max + 1));
        child->name[0] = '\0';
        child->level = i;
        CALL_glGetActiveAttrib(self->object, i, max, &length, &size,
                               &type, child->name);
        if (length) bugle_list_append(children, child);
        else free(child->name);
    }
}
#endif

#if defined(GL_ARB_vertex_program) || defined(GL_ARB_fragment_program)
static void spawn_children_old_program_object(const glstate *self, bugle_linked_list *children)
{
    uint32_t mask = 0;
    GLint max_local, i;
    GLdouble local[4];
    static const state_info program_local_state =
    {
        NULL, GL_NONE, TYPE_8GLdouble, 4, BUGLE_EXTGROUP_old_program, STATE_PROGRAM_LOCAL_PARAMETER
    };

    bugle_list_init(children, true);
#ifdef GL_ARB_vertex_program
    if (self->target == GL_ARB_vertex_program) mask = STATE_SELECT_FRAGMENT;
#endif
#ifdef GL_ARB_fragment_program
    if (self->target == GL_ARB_fragment_program) mask = STATE_SELECT_VERTEX;
#endif
    make_leaves_conditional(self, old_program_object_state, 0, mask, children);

    CALL_glGetProgramivARB(self->target, GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB, &max_local);
    for (i = 0; i < max_local; i++)
    {
        CALL_glGetProgramLocalParameterdvARB(self->target, i, local);
        if (local[0] || local[1] || local[2] || local[3])
        {
            glstate *child;

            child = bugle_malloc(sizeof(glstate));
            *child = *self;
            child->level = i;
            child->info = &program_local_state;
            child->spawn_children = NULL;
            bugle_asprintf(&child->name, "Local[%lu]", (unsigned long) i);
            bugle_list_append(children, child);
        }
    }
}

static void spawn_children_old_program(const glstate *self, bugle_linked_list *children)
{
    uint32_t mask = 0;
    GLint max_env, i;
    GLdouble env[4];
    static const state_info program_env_state =
    {
        NULL, GL_NONE, TYPE_8GLdouble, 4, BUGLE_EXTGROUP_old_program, STATE_PROGRAM_ENV_PARAMETER
    };

    bugle_list_init(children, true);
#ifdef GL_ARB_vertex_program
    if (self->target == GL_ARB_vertex_program) mask = STATE_SELECT_FRAGMENT;
#endif
#ifdef GL_ARB_fragment_program
    if (self->target == GL_ARB_fragment_program) mask = STATE_SELECT_VERTEX;
#endif
    make_leaves_conditional(self, old_program_state, 0, mask, children);
    CALL_glGetProgramivARB(self->target, GL_MAX_PROGRAM_ENV_PARAMETERS_ARB, &max_env);
    for (i = 0; i < max_env; i++)
    {
        CALL_glGetProgramEnvParameterdvARB(self->target, i, env);
        if (env[0] || env[1] || env[2] || env[3])
        {
            glstate *child;

            child = bugle_malloc(sizeof(glstate));
            *child = *self;
            child->level = i;
            child->info = &program_env_state;
            child->spawn_children = NULL;
            bugle_asprintf(&child->name, "Env[%lu]", (unsigned long) i);
            bugle_list_append(children, child);
        }
    }
    make_objects(self, BUGLE_TRACKOBJECTS_OLD_PROGRAM, self->target, false,
                 "%lu", spawn_children_old_program_object, NULL, children);
}
#endif /* GL_ARB_vertex_program || GL_ARB_fragment_program */

static void spawn_children_global(const glstate *self, bugle_linked_list *children)
{
    static const state_info enable =
    {
        NULL, GL_NONE, TYPE_9GLboolean, -1, BUGLE_GL_VERSION_1_1, STATE_ENABLED
    };
    /* FIXME: clip plane enables */
    static const state_info clip_plane_state =
    {
        NULL, GL_NONE, TYPE_8GLdouble, 4, BUGLE_GL_VERSION_1_1, STATE_CLIP_PLANE
    };
#ifdef GL_ATI_draw_buffers
    static const state_info draw_buffers =
    {
        NULL, GL_NONE, TYPE_6GLenum, -1, BUGLE_GL_ATI_draw_buffers, STATE_GLOBAL
    };
#endif

    GLint count, i;
    const char *version;

    version = (const char *) glGetString(GL_VERSION);
    bugle_list_init(children, true);
    make_leaves(self, global_state, children);

#ifdef GL_ARB_multitexture
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_multitexture))
    {
        count = get_total_texture_units();
        make_counted(self, count, "GL_TEXTURE%lu", GL_TEXTURE0_ARB,
                     offsetof(glstate, unit), spawn_children_tex_unit,
                     NULL, children);
    }
    else
#endif
    {
        make_leaves(self, tex_unit_state, children);
    }
    CALL_glGetIntegerv(GL_MAX_LIGHTS, &count);
    make_counted(self, count, "GL_LIGHT%lu", GL_LIGHT0,
                 offsetof(glstate, target), spawn_children_light,
                 &enable, children);

    CALL_glGetIntegerv(GL_MAX_CLIP_PLANES, &count);
    make_counted(self, count, "GL_CLIP_PLANE%lu", GL_CLIP_PLANE0,
                 offsetof(glstate, target), NULL,
                 &clip_plane_state, children);

#ifdef GL_ATI_draw_buffers
    if (bugle_gl_has_extension_group(BUGLE_GL_ATI_draw_buffers))
    {
        CALL_glGetIntegerv(GL_MAX_DRAW_BUFFERS_ATI, &count);
        make_counted(self, count, "GL_DRAW_BUFFER%lu", GL_DRAW_BUFFER0_ATI,
                     offsetof(glstate, target), NULL,
                     &draw_buffers, children);
    }
#endif

    make_fixed(self, material_pairs, offsetof(glstate, target),
               spawn_children_material, children);
    make_fixed(self, color_table_parameter_pairs, offsetof(glstate, target),
               spawn_children_color_table_parameter, children);
    make_fixed(self, convolution_parameter_pairs, offsetof(glstate, target),
               spawn_children_convolution_parameter, children);
    make_fixed(self, histogram_parameter_pairs, offsetof(glstate, target),
               spawn_children_histogram_parameter, children);
    make_fixed(self, minmax_parameter_pairs, offsetof(glstate, target),
               spawn_children_minmax_parameter, children);

#ifdef GL_ARB_vertex_program
    if (bugle_gl_has_extension_group(BUGLE_EXTGROUP_vertex_attrib))
    {
        CALL_glGetIntegerv(GL_MAX_VERTEX_ATTRIBS_ARB, &count);
        for (i = 0; i < count; i++)
            make_object(self, 0, "VertexAttrib[%lu]", i, spawn_children_vertex_attrib, NULL, children);
    }
#endif

    make_target(self, "GL_TEXTURE_1D", GL_TEXTURE_1D,
                GL_TEXTURE_BINDING_1D, spawn_children_tex_target, NULL, children);
    make_target(self, "GL_PROXY_TEXTURE_1D", GL_PROXY_TEXTURE_1D,
                0, spawn_children_tex_target, NULL, children);
    make_target(self, "GL_TEXTURE_2D", GL_TEXTURE_2D,
                GL_TEXTURE_BINDING_2D, spawn_children_tex_target, NULL, children);
    make_target(self, "GL_PROXY_TEXTURE_2D", GL_PROXY_TEXTURE_2D,
                0, spawn_children_tex_target, NULL, children);
#ifdef GL_VERSION_1_2
    if (bugle_gl_has_extension_group(BUGLE_GL_VERSION_1_2))
    {
        make_target(self, "GL_TEXTURE_3D", GL_TEXTURE_3D,
                        GL_TEXTURE_BINDING_3D, spawn_children_tex_target, NULL, children);
        make_target(self, "GL_PROXY_TEXTURE_3D", GL_PROXY_TEXTURE_3D,
                        0, spawn_children_tex_target, NULL, children);
    }
#endif
#ifdef GL_ARB_texture_cube_map
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_texture_cube_map))
    {
        make_target(self, "GL_TEXTURE_CUBE_MAP",
                    GL_TEXTURE_CUBE_MAP_ARB,
                    GL_TEXTURE_BINDING_CUBE_MAP_ARB,
                    spawn_children_tex_target, NULL, children);
        make_target(self, "GL_PROXY_TEXTURE_CUBE_MAP",
                    GL_PROXY_TEXTURE_CUBE_MAP_ARB,
                    0,
                    spawn_children_tex_target, NULL, children);
    }
#endif
#ifdef GL_NV_texture_rectangle
    if (bugle_gl_has_extension_group(BUGLE_GL_NV_texture_rectangle))
    {
        make_target(self, "GL_TEXTURE_RECTANGLE",
                    GL_TEXTURE_RECTANGLE_NV,
                    GL_TEXTURE_BINDING_RECTANGLE_NV,
                    spawn_children_tex_target, NULL, children);
        make_target(self, "GL_PROXY_TEXTURE_RECTANGLE",
                    GL_PROXY_TEXTURE_RECTANGLE_NV,
                    0,
                    spawn_children_tex_target, NULL, children);
    }
#endif

#ifdef GL_ARB_occlusion_query
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_occlusion_query))
    {
        make_fixed(self, query_pairs, offsetof(glstate, target),
                   spawn_children_query, children);
        make_objects(self, BUGLE_TRACKOBJECTS_QUERY, GL_NONE, false,
                     "Query[%lu]", spawn_children_query_object, NULL, children);
    }
#endif
#ifdef GL_ARB_vertex_buffer_object
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_vertex_buffer_object))
    {
        make_objects(self, BUGLE_TRACKOBJECTS_BUFFER, GL_NONE, false,
                     "Buffer[%lu]", spawn_children_buffer_parameter, NULL, children);
    }
#endif
#ifdef GL_ARB_shader_objects
    if (bugle_gl_has_extension(BUGLE_GL_ARB_shader_objects))
    {
        make_objects(self, BUGLE_TRACKOBJECTS_SHADER_OBJECT, GL_NONE, false,
                     "Object[%lu]", spawn_children_shader_object, NULL, children);
        make_objects(self, BUGLE_TRACKOBJECTS_PROGRAM_OBJECT, GL_NONE, false,
                     "Object[%lu]", spawn_children_program_object, NULL, children);
    }
#endif
#ifdef GL_VERSION_2_0
    if (bugle_gl_has_extension_group(BUGLE_GL_VERSION_2_0))
    {
        make_objects(self, BUGLE_TRACKOBJECTS_SHADER, GL_NONE, false,
                     "Shader[%lu]", spawn_children_shader, NULL, children);
        make_objects(self, BUGLE_TRACKOBJECTS_PROGRAM, GL_NONE, false,
                     "Program[%lu]", spawn_children_program, NULL, children);
    }
#endif
#ifdef GL_ARB_vertex_program
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_vertex_program))
        make_target(self, "GL_VERTEX_PROGRAM_ARB",
                    GL_VERTEX_PROGRAM_ARB,
                    0, spawn_children_old_program, &enable, children);
#endif
#ifdef GL_ARB_fragment_program
    if (bugle_gl_has_extension_group(BUGLE_GL_ARB_fragment_program))
        make_target(self, "GL_FRAGMENT_PROGRAM_ARB",
                    GL_FRAGMENT_PROGRAM_ARB,
                    0, spawn_children_old_program, &enable, children);
#endif
}

const glstate *bugle_state_get_root(void)
{
    static const glstate root =
    {
        "", GL_NONE, GL_NONE, GL_NONE, GL_NONE,
        0, 0, NULL, spawn_children_global
    };

    return &root;
}
